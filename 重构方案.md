# Flora 多智能体协作系统重构方案

目前是基于我是基于thspian的同步执行架构的，这个系统里以agent_actor（agent/agent_actor.py）为是最基础的单元，每个agent_actor都具有记忆（存储每条执行的指令以及对应的结果和反馈，通过agent/memory/memory_actor.py 调用 llm_memory_system能力进行存储），处理的任务有两种，一种是外部任务，一种是循环任务，外部任务是来源于外部，循环任务是来自于自己隶属的optimization，里面会存储所有的循环任务（包括相应的持久化接口），并对循环任务进行优化，优化是利用multifeature中相关能力来实现，任务来后会经过，任务分配（根据自己的能力描述选择task_coordinator._select_best_actor），任务规划（通过task_coordinator.plan_subtasks，调用外部的decision_engine能力来进行规划），执行前会先获取执行所需的参数，然后由记忆补足一部分，记忆无法补足的则通过_task_coordinator.resolve_context调用agent/io中的能力去向其他智能体请求相关数据来获取数据，然后去具体的调用执行（分两种，第一种是创建并分发给业务上下一级的agent_actor进行执行，所有agent_actor行为是一样的，所以这里会出现调多层agent_actor的情况，所以这里是_report_event（agent_actor的方法）来完成整个链路的报告与追踪 。另一种是下一级是某项具体的能力，例如这里是dify能力，也有可能是其他能力这里还要注意的是，执行应该分两种，一种是普通执行，另一种是并列执行，并列执行是调用agent/concurrent里的方法，首先决定优化维度，然后调用optuna创建维度优化，然后创建多个同任务智能体进行并行执行，执行完后再提交optuna生成下一轮参数，等待下一轮执行再传入进行执行），然后每个情况都需要推送给Observer去进行记录（包括执行，审查，资源等），所有的执行记录都从observer统一获取，注意：（1）循环任务本质上也是一种外部任务，是由外部添加的，然后再循环执行，并给这种执行创建了优化，（2）optuna是用在并行执行优化上的，这个和循环任务是两种，一个是任务是需要重复执行的（例如日报），一种是任务值得多方向探索的（例如写方案），这是两种东西，


## 1. 系统现状分析

Flora 是一个多智能体协作系统，目前架构存在以下主要问题：

1. 任务执行模型不清晰，循环任务和并行执行机制未与具体 agent_actor 绑定
2. 任务协调器 (TaskCoordinator) 职责过重，包含路由、规划和上下文解析等多种功能
3. 外部连接和能力接入缺乏统一的插件化接口标准
4. 任务提交和执行流程未充分利用树形组织结构的优势
5. 各组件之间的耦合度较高，影响系统的可维护性和扩展性

## 2. 重构目标

1. 建立以 agent_actor 为核心的树形组织结构，优化任务流转机制
2. 实现任务从租户根 actor 向下传递，由路径中的 agent_actor 自主决定任务类型处理
3. 将 TaskCoordinator 拆分为三个独立组件，明确职责边界
4. 实现外部连接和能力接入的插件化接口标准
5. 提升系统的性能、可维护性和可扩展性

## 3. 架构设计

### 3.1 整体架构

采用以 agent_actor 为核心的树形组织结构，系统分为以下六个层次：

1. **入口层**：系统外部访问入口，负责接收用户请求并转发到对应租户的根 actor
2. **外部对接层**：底层能力层与外部系统的对接层，负责连接持久化、外部数据库、外部API、dify等，采用插件化设计方便切换
3. **底层能力层**：提供各种基础能力，位于外部连接层之上，采用插件化设计，方便actor加载
4. **能力 actor 层**：作为底层能力与actor系统之间的转换层，包装底层能力使其能在actor系统中使用
5. **agent_actor 层**：系统核心，负责任务处理、决策和向下传递，以树形结构组织
6. **事件报告层**：统一的事件发布和订阅机制

### 3.2 核心组件设计

#### 3.2.1 AgentActor 树形结构

- **根节点**：租户配置对应的根 actor，作为任务接收入口
- **中间节点**：负责任务向下传递和决策，其能力由子actor决定
- **叶子节点**：负责具体任务执行，包含实际的执行能力

树形结构维护在Neo4j图数据库中，通过agent_registry加载。每个agent_actor的能力也存储在Neo4j图中，由agent_registry负责加载。

**中间节点AgentActor的能力**：
- 表示其子actor能够执行的任务类型和功能，由agent_registry加载
- 负责任务分发和路由到合适的子actor
- 不直接执行具体任务，只关心"能做什么"，不关心"具体怎么做"

**所有AgentActor共有的核心组件**：
- 任务处理器
- 循环任务管理器
- 并行执行管理器
- 优化器接口
- 任务路由器
- 任务规划器
- 上下文解析器
- 记忆

#### 3.2.2 任务协调拆分组件

1. **TaskRouter**：负责选择最佳的 actor 执行任务
2. **TaskPlanner**：负责子任务分解与规划
3. **ContextResolver**：负责补全缺失的上下文信息

#### 3.2.3 外部对接层

底层能力层与外部系统的对接层，负责连接：
- 持久化存储系统
- 外部数据库
- 外部API服务
- Dify等第三方平台
采用插件化设计，方便切换不同的实现。

#### 3.2.4 底层能力层

提供各种基础能力，包括：
1. **维度转换**：用于优化过程中的参数空间转换，agent\concurrent\llm_demension_parser.py
2. **协调执行**：协调多个组件的执行流程，change_orchestrator\decision_engine.py
3. **具体执行**：执行具体的业务逻辑，agent\excute\dify_actor.py
4. **数据查询**：提供数据检索和查询能力，agent\io\data_actor.py
5. **MCP（大模型上下文工具）**：管理大模型的上下文信息，agent\mcp\mcp_actor.py
6. **记忆**：提供记忆存储和检索能力，llm_memory_system
7. **优化**：提供任务优化机制，multifeature

采用插件化设计，方便actor加载和使用。

#### 3.2.5 能力 Actor 层

作为底层能力与actor系统之间的转换层，包装底层能力使其能在actor系统中使用。包括：
- MemoryActor：包装记忆能力
- DataQueryActor：包装数据查询能力
- 其他需要在actor系统中使用的能力包装器




## 5. 系统集成与数据流

### 5.1 任务执行流程

#### 5.1.1 标准任务执行流程

1. 用户通过入口层提交任务到对应的租户根 actor
2. 根 actor 接收任务，从agent_registry加载自身能力和树结构
3. 任务通过树形结构向下传递：
   - 中间节点：基于子actor的能力进行路由决策，只关心"能做什么"，不关心"具体怎么做"
   - 每个节点决定：是否创建循环任务、是否进行并行执行、是否调用优化器
4. 最终由叶子节点执行任务，通过能力actor层调用底层能力
5. 结果沿路径向上返回给用户

**中间节点与叶子节点的职责区分**：
- 中间节点：管理子actor，基于子actor的能力进行任务分发，是任务的协调者
- 叶子节点：执行具体任务，是任务的执行者

#### 5.1.2 循环任务执行流程

1. 任务在向下传递过程中，某个 agent_actor 判断需要创建循环任务
2. 该 agent_actor 在自己的循环任务管理器中创建任务
3. 循环任务管理器根据配置定期执行任务
4. 执行结果通过事件报告层通知相关组件

#### 5.1.3 并行执行优化流程

1. 任务在向下传递过程中，某个 agent_actor 判断需要进行并行执行
2. 该 agent_actor 评估系统资源，决定优化维度数
3. 并行执行管理器根据优化维度数拆分任务
4. 并行执行子任务并聚合结果
5. 聚合结果沿路径向上返回给用户

### 5.2 数据流

```
用户请求 -> 入口层 -> 租户根 Actor -> 中间层 AgentActor -> 叶子节点 AgentActor
                                    |             |               |
                                    v             v               v
                                循环任务管理     并行执行管理      具体任务执行
                                    |             |               |
                                    v             v               v
                                 事件总线 <- 结果聚合 <- 能力组件/外部系统
```

## 6. 实现路线图

### 6.1 第一阶段：核心架构重构

1. 重构 AgentActor，使其不再是上帝模块，拆分其功能，让其可读性和更改更简单
2. 拆分 TaskCoordinator 为三个独立组件
3. 实现外部对接层接口标准化
4. 实现底层能力层接口标准化和插件化设计
5. 实现能力Actor层作为转换层

### 6.2 第二阶段：任务执行模型优化

1. 实现循环任务管理器，支持任务归属到具体 agent_actor
2. 实现并行执行管理器，支持由 agent_actor 自主决定并行策略
3. 优化任务向下传递的决策机制

### 6.3 第三阶段：系统集成与测试

1. 集成各组件，构建完整的执行流程
2. 编写单元测试和集成测试
3. 进行性能测试和优化

### 6.4 第四阶段：部署与监控

1. 部署重构后的系统
2. 实现系统监控和日志记录
3. 进行系统稳定性测试

## 7. 预期收益

1. **提升系统可维护性**：清晰的组件职责和接口定义，降低代码复杂度
2. **增强系统扩展性**：插件化设计支持快速添加新功能和外部系统对接
3. **优化任务执行效率**：并行执行和智能路由机制提升处理速度
4. **降低系统耦合度**：组件之间通过明确的接口通信，减少直接依赖
5. **提升系统可靠性**：错误隔离和故障恢复机制增强系统稳定性

## 8. 风险应对策略

1. **技术风险**：
   - 风险：树形结构可能导致任务传递路径过长
   - 应对：实现路径优化算法，避免不必要的节点跳转

2. **性能风险**：
   - 风险：并行执行可能导致系统资源过度消耗
   - 应对：实现资源监控和自适应调度机制

3. **兼容性风险**：
   - 风险：重构可能影响现有功能
   - 应对：编写全面的测试用例，确保功能兼容性

4. **部署风险**：
   - 风险：部署过程可能导致服务中断
   - 应对：采用蓝绿部署或金丝雀发布策略

5. **扩展性风险**：
   - 风险：随着系统规模扩大，性能可能下降
   - 应对：实现水平扩展机制，支持动态增减节点