# Flora Agent 系统整合说明

## 项目概述

Flora Agent 是一个基于 Thespian Actor 模型的智能体系统，支持任务管理、循环任务调度、插件化能力扩展等功能。

## 核心架构

### 1. 消息处理流程（AgentActor）

当 `AgentActor` 收到任务消息后，按以下步骤处理：

```
用户输入
  ↓
① 草稿判断（TaskDraft）
  ├─ 检查是否为"继续"请求
  ├─ 恢复未完成的草稿
  └─ 或创建新草稿
  ↓
② 意图判断（IntentRouter）
  ├─ 使用 Qwen LLM 分类意图
  ├─ 判断：task / query / chat / system
  └─ 需要澄清时返回澄清选项
  ↓
③ 任务操作判断（TaskPlanner）
  ├─ new_task: 创建新任务
  ├─ comment_on_task: 追加评论
  ├─ revise_result: 修改结果
  ├─ re_run_task: 重新执行
  ├─ cancel_task: 取消任务
  └─ 循环任务操作: trigger/modify/pause/resume
  ↓
④ 循环任务检测
  ├─ 使用 LLM 判断是否为循环任务
  ├─ 是 → 注册到 LoopSchedulerActor
  │     ├─ 发送到 RabbitMQ
  │     ├─ RabbitBridge 桥接到 Thespian
  │     └─ 定时触发执行
  └─ 否 → 继续普通任务流程
  ↓
⑤ 能力路由（TaskRouter）
  ├─ 根据任务描述选择最佳能力节点
  └─ 未找到 → 使用 MCP Fallback
  ↓
⑥ 任务规划（TaskPlanner）
  ├─ 生成子任务执行计划
  └─ 支持 SCC 强耦合任务协同规划
  ↓
⑦ 任务分发（ExecutionActor）
  ├─ 创建子任务
  ├─ 分配到执行器
  └─ 跟踪执行状态
  ↓
⑧ 组任务管理（TaskGroupAggregatorActor）
  ├─ 批量分发子任务
  ├─ 支持任务重试
  └─ 聚合执行结果
  ↓
⑨ 并行执行判断（parallel_task_aggregator_actor.py）
  ├─ 判断是否需要并行执行
  ├─ 使用 Optuna 进行参数优化
  └─ 并发执行多个任务
  ↓
⑩ 单任务执行（ResultAggregatorActor）
  ├─ leaf_task: 叶子节点任务
  ├─ intermediate_task: 中间任务
  └─ workflow_task: 工作流任务（Dify）
  ↓
⑪ 结果聚合（ResultAggregator）
  ├─ 收集所有子任务结果
  ├─ 按策略聚合（map_reduce / voting / weighted）
  └─ 返回最终结果
  ↓
⑫ 事件通知（EventBus）
  ├─ 发布任务状态变更事件
  ├─ 通知订阅者
  └─ 记录任务历史
```

### 2. 核心组件

#### 2.1 AgentActor (agents/agent_actor.py)
- 核心消息处理器
- 协调所有能力模块
- 管理任务生命周期

#### 2.2 LoopSchedulerActor (capability_actors/loop_scheduler_actor.py)
- 循环任务调度
- RabbitMQ 集成
- 任务触发管理

#### 2.3 TaskCoordinator (agents/coordination/task_coordinator.py)
- 任务协调
- 子任务生成
- 状态跟踪

#### 2.4 TaskExecutionService (capability_actors/task_execution_service.py)
- 任务执行引擎
- 支持多种任务类型
- 资源管理

#### 2.5 EventBus (events/event_bus.py)
- 事件发布/订阅
- 解耦组件通信
- 事件历史记录

### 3. 插件系统

所有能力组件都通过 `CapabilityRegistry` 插件式注册：

```python
from capabilities.registry import capability_registry
from init_plugins import init_plugins

# 初始化所有插件
init_plugins()

# 获取能力
router = capability_registry.get_capability("routing")
planner = capability_registry.get_capability("planning")
```

已注册的能力：
- `routing`: TaskRouter - 任务路由
- `planning`: TaskPlanner - 任务规划
- `context_resolver`: ContextResolver - 上下文解析
- `result_aggregation`: ResultAggregator - 结果聚合
- `parallel_optimization`: OptunaOptimizer - 并行优化
- `optimization`: MultiFeatureOptimizer - 循环优化
- `memory`: MemoryCapability - 记忆能力
- `decision_engine`: DecisionEngine - 决策引擎
- `data_access`: DataAccessor - 数据访问
- `loop_queue`: QueueFactory - 循环队列
- `llm`: QwenAdapter - LLM 能力

### 4. 全局初始化

系统启动时调用 `init_global_components()`：

```python
from init_global_components import init_global_components

# 异步初始化所有组件
components = await init_global_components()
```

初始化内容包括：
1. 插件系统
2. Thespian Actor System
3. Agent 注册表（Neo4j）
4. RabbitMQ 桥接器
5. 事件总线
6. 全局 LoopSchedulerActor

### 5. 事件系统

系统在关键节点发布事件：

```python
from events.event_bus import event_bus
from events.event_types import EventType

# 发布任务事件
event_bus.publish_task_event(
    task_id=task_id,
    event_type=EventType.TASK_STARTED.value,
    source="AgentActor",
    agent_id=self.agent_id,
    data={"description": task_description}
)
```

支持的事件类型：
- TASK_CREATED: 任务创建
- TASK_STARTED: 任务开始
- TASK_COMPLETED: 任务完成
- TASK_FAILED: 任务失败
- TASK_CANCELLED: 任务取消
- LOOP_TASK_REGISTERED: 循环任务注册
- TASK_TRIGGERED: 任务触发

### 6. 循环任务管理

#### 6.1 RabbitMQ 桥接
```
RabbitMQ Queue (loop.trigger.queue)
    ↓
RabbitBridge (rabbit_bridge.py)
    ↓
LoopSchedulerActor (Thespian)
    ↓
AgentActor (执行任务)
```

#### 6.2 循环任务注册流程
1. AgentActor 检测到循环任务
2. 向 LoopSchedulerActor 注册任务
3. LoopSchedulerActor 保存到 TaskRegistry
4. 定时触发或通过 RabbitMQ 触发
5. 执行任务并更新状态

### 7. 依赖关系

```
agents/
  ├── agent_actor.py (依赖所有 capabilities)
  └── coordination/
      └── task_coordinator.py (依赖 TaskPlanner)

capabilities/
  ├── registry.py (中心注册表)
  ├── routing/
  │   ├── task_router.py
  │   ├── task_planner.py
  │   └── context_resolver.py
  ├── llm/
  │   └── qwen_adapter.py
  └── llm_memory/
      └── memory_capability.py

capability_actors/
  ├── loop_scheduler_actor.py (依赖 TaskRegistry, EventBus)
  ├── task_execution_service.py (依赖 ExecutionActor)
  └── task_group_aggregator_actor.py

events/
  ├── event_bus.py (单例，全局使用)
  └── event_types.py

common/
  ├── draft/ (草稿管理)
  ├── intent/ (意图识别)
  └── tasks/ (任务模型)
```

## 使用示例

### 创建简单任务

```python
from thespian.actors import ActorSystem
from agents.agent_actor import AgentActor

# 创建 Actor System
system = ActorSystem("multiprocTCPBase")

# 创建 AgentActor
agent = system.createActor(AgentActor)

# 发送初始化消息
init_msg = {
    "message_type": "init",
    "agent_id": "test_agent",
}
system.ask(agent, init_msg, timeout=10)

# 发送任务消息
task_msg = {
    "message_type": "agent_task",
    "task_id": "task_001",
    "description": "帮我分析一下销售数据",
    "user_id": "user_001"
}
result = system.ask(agent, task_msg, timeout=60)
print(result)
```

### 创建循环任务

```python
task_msg = {
    "message_type": "agent_task",
    "task_id": "daily_report",
    "description": "每天生成销售报告",
    "user_id": "user_001"
}
result = system.ask(agent, task_msg, timeout=60)
# 系统会自动检测并注册为循环任务
```

## 注意事项

1. **import 路径**: 统一使用新的模块结构，不要使用 `new.` 前缀
2. **插件注册**: 所有能力必须在 `init_plugins()` 中注册
3. **事件发布**: 在关键状态变更时发布事件
4. **Actor 生命周期**: 避免阻塞操作，使用消息传递
5. **错误处理**: 使用 try-except 包裹外部调用
6. **配置管理**: 通过 `config.py` 管理全局配置

## 待完善项

- [ ] 添加更多事件发布点
- [ ] 完善错误处理和重试机制
- [ ] 添加性能监控和日志
- [ ] 编写完整的集成测试
- [ ] 添加 API 文档
