<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neo4j 双结构节点编辑器</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 本地Font Awesome -->
    <link href="cdn/css/font-awesome.min.css" rel="stylesheet">
    <!-- 本地Cytoscape.js -->
    <script src="cdn/js/cytoscape.min.js"></script>
    <!-- 本地Axios -->
    <script src="cdn/js/axios.min.js"></script>
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3B82F6',
                        secondary: '#10B981',
                        dark: '#111827',
                        darker: '#030712',
                        surface: '#1F2937',
                        accent: '#8B5CF6'
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif']
                    }
                }
            }
        }
    </script>
    
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .graph-container {
                height: calc(100vh - 12rem);
            }
            .sidebar {
                height: calc(100vh - 12rem);
                overflow-y: auto;
            }
            .btn-action {
                @apply px-4 py-2 rounded-md text-white font-medium transition-all duration-200;
            }
            .btn-primary {
                @apply bg-primary hover:bg-blue-600;
            }
            .btn-secondary {
                @apply bg-secondary hover:bg-green-600;
            }
            .btn-accent {
                @apply bg-accent hover:bg-purple-600;
            }
            .btn-danger {
                @apply bg-red-600 hover:bg-red-700;
            }
            .btn-connect {
                @apply bg-blue-700 hover:bg-blue-800;
            }
            .form-input {
                @apply w-full px-3 py-2 bg-surface border border-gray-700 rounded-md text-gray-200 focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent;
            }
            .form-label {
                @apply block text-sm font-medium text-gray-300 mb-1;
            }
            .form-group {
                @apply mb-4;
            }
            .card {
                @apply bg-surface rounded-lg shadow-lg p-4 mb-4 border border-gray-700;
            }
            .badge {
                @apply px-2 py-1 text-xs font-semibold rounded-full;
            }
            .badge-primary {
                @apply bg-blue-900 text-blue-300;
            }
            .badge-secondary {
                @apply bg-green-900 text-green-300;
            }
        }
    </style>
</head>
<body class="bg-dark text-gray-200">
    <div class="container mx-auto px-4 py-6">
        <!-- Header -->
        <header class="mb-6">
            <div class="flex justify-between items-center">
                <div>
                    <h1 class="text-3xl font-bold text-white">Neo4j 双结构节点编辑器</h1>
                    <p class="text-gray-400">同时管理层级树和同级网关系</p>
                </div>
                <div class="flex space-x-4">
                    <button id="btn-connect" class="btn-action btn-connect">
                        <i class="fa fa-database mr-2"></i>Neo4j连接
                    </button>
                    <button id="btn-save" class="btn-action btn-primary">
                        <i class="fa fa-save mr-2"></i>保存
                    </button>
                    <button id="btn-load" class="btn-action btn-secondary">
                        <i class="fa fa-refresh mr-2"></i>加载
                    </button>
                </div>
            </div>
        </header>
        
        <!-- Toolbar -->
        <div class="bg-surface rounded-lg shadow-lg p-4 mb-6 border border-gray-700">
            <div class="flex flex-wrap gap-4">
                <div class="flex space-x-2">
                    <button id="btn-add-node" class="btn-action btn-primary">
                        <i class="fa fa-plus mr-2"></i>添加节点
                    </button>
                    <button id="btn-delete-node" class="btn-action btn-danger">
                        <i class="fa fa-trash mr-2"></i>删除节点
                    </button>
                </div>
                
                <div class="flex space-x-2">
                    <button id="btn-add-parent" class="btn-action btn-secondary">
                        <i class="fa fa-arrow-up mr-2"></i>设置父节点
                    </button>
                    <button id="btn-remove-parent" class="btn-action btn-secondary">
                        <i class="fa fa-arrow-down mr-2"></i>移除父节点
                    </button>
                </div>
                
                <div class="flex space-x-2">
                    <button id="btn-add-connection" class="btn-action btn-accent">
                        <i class="fa fa-link mr-2"></i>添加同级连接
                    </button>
                    <button id="btn-remove-connection" class="btn-action btn-accent">
                        <i class="fa fa-unlink mr-2"></i>移除同级连接
                    </button>
                </div>
                
                <div class="flex-grow"></div>
                
                <div>
                    <button id="btn-batch-update" class="btn-action btn-secondary">
                        <i class="fa fa-batch mr-2"></i>批量更新属性
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Main Content -->
        <div class="flex flex-col lg:flex-row gap-6">
            <!-- Left Panel - Hierarchical Tree -->
            <div class="w-full lg:w-1/2">
                <div class="bg-surface rounded-lg shadow-lg p-4 border border-gray-700">
                    <h2 class="text-xl font-semibold text-white mb-4">
                        <i class="fa fa-sitemap mr-2"></i>层级树结构
                    </h2>
                    <div id="tree-graph" class="graph-container border border-gray-700 rounded-lg bg-darker"></div>
                </div>
            </div>
            
            <!-- Right Panel - Network Graph -->
            <div class="w-full lg:w-1/2">
                <div class="bg-surface rounded-lg shadow-lg p-4 border border-gray-700">
                    <h2 class="text-xl font-semibold text-white mb-4">
                        <i class="fa fa-share-alt mr-2"></i>同级网结构
                    </h2>
                    <div id="network-graph" class="graph-container border border-gray-700 rounded-lg bg-darker"></div>
                </div>
            </div>
        </div>
        
        <!-- Property Editor (Hidden by default) -->
        <div id="property-editor" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
            <div class="bg-surface rounded-lg shadow-xl p-6 w-full max-w-2xl border border-gray-700">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl font-semibold text-white" id="editor-title">编辑节点属性</h2>
                    <button id="btn-close-editor" class="text-gray-400 hover:text-white">
                        <i class="fa fa-times text-xl"></i>
                    </button>
                </div>
                
                <form id="property-form">
                    <input type="hidden" id="node-id">
                    
                    <div class="form-group">
                        <label for="node-name" class="form-label">节点名称</label>
                        <input type="text" id="node-name" class="form-input" required>
                    </div>
                    
                    <div class="form-group">
                        <label for="node-type" class="form-label">节点类型</label>
                        <input type="text" id="node-type" class="form-input" required>
                    </div>
                    
                    <div class="form-group">
                        <label for="node-level" class="form-label">层级</label>
                        <input type="number" id="node-level" class="form-input" min="0" required>
                    </div>
                    
                    <div class="form-group">
                        <label for="node-properties" class="form-label">自定义属性 (JSON格式)</label>
                        <textarea id="node-properties" class="form-input" rows="4" placeholder='{"key": "value"}'></textarea>
                    </div>
                    
                    <div class="flex justify-end space-x-4 mt-6">
                        <button type="button" id="btn-cancel-editor" class="px-4 py-2 border border-gray-700 rounded-md text-gray-300 hover:bg-gray-800">取消</button>
                        <button type="submit" class="btn-action btn-primary">保存</button>
                    </div>
                </form>
            </div>
        </div>
        
        <!-- Neo4j Connection Dialog (Hidden by default) -->
        <div id="neo4j-connection-dialog" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
            <div class="bg-surface rounded-lg shadow-xl p-6 w-full max-w-lg border border-gray-700">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl font-semibold text-white">Neo4j 连接设置</h2>
                    <button id="btn-close-connection" class="text-gray-400 hover:text-white">
                        <i class="fa fa-times text-xl"></i>
                    </button>
                </div>
                
                <form id="neo4j-connection-form">
                    <div class="form-group">
                        <label for="neo4j-uri" class="form-label">URI</label>
                        <input type="text" id="neo4j-uri" class="form-input" value="bolt://localhost:7687" required>
                    </div>
                    
                    <div class="form-group">
                        <label for="neo4j-user" class="form-label">用户名</label>
                        <input type="text" id="neo4j-user" class="form-input" value="neo4j" required>
                    </div>
                    
                    <div class="form-group">
                        <label for="neo4j-password" class="form-label">密码</label>
                        <input type="password" id="neo4j-password" class="form-input" required>
                    </div>
                    
                    <div class="form-group">
                        <label for="neo4j-database" class="form-label">数据库名称</label>
                        <input type="text" id="neo4j-database" class="form-input" value="neo4j">
                    </div>
                    
                    <div class="form-group">
                        <label for="backend-url" class="form-label">后端API地址</label>
                        <input type="text" id="backend-url" class="form-input" value="http://localhost:8000" required>
                    </div>
                    
                    <div class="flex justify-between items-center mt-6">
                        <button type="button" id="btn-test-connection" class="btn-action btn-secondary">
                            <i class="fa fa-check-circle mr-2"></i>测试连接
                        </button>
                        <div class="flex space-x-4">
                            <button type="button" id="btn-cancel-connection" class="px-4 py-2 border border-gray-700 rounded-md text-gray-300 hover:bg-gray-800">取消</button>
                            <button type="submit" class="btn-action btn-connect">
                                <i class="fa fa-save mr-2"></i>保存设置
                            </button>
                        </div>
                    </div>
                </form>
                
                <div id="connection-status" class="mt-4 hidden">
                    <div id="connection-success" class="bg-green-900 bg-opacity-30 border border-green-700 rounded-md p-3 text-green-400">
                        <i class="fa fa-check-circle mr-2"></i>连接成功
                    </div>
                    <div id="connection-error" class="bg-red-900 bg-opacity-30 border border-red-700 rounded-md p-3 text-red-400 hidden">
                        <i class="fa fa-exclamation-circle mr-2"></i>
                        <span id="connection-error-message">连接失败</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Batch Property Update (Hidden by default) -->
        <div id="batch-update" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
            <div class="bg-surface rounded-lg shadow-xl p-6 w-full max-w-2xl border border-gray-700">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl font-semibold text-white">批量更新属性</h2>
                    <button id="btn-close-batch" class="text-gray-400 hover:text-white">
                        <i class="fa fa-times text-xl"></i>
                    </button>
                </div>
                
                <form id="batch-form">
                    <div class="form-group">
                        <label for="batch-property-key" class="form-label">属性键</label>
                        <input type="text" id="batch-property-key" class="form-input" required>
                    </div>
                    
                    <div class="form-group">
                        <label for="batch-property-value" class="form-label">属性值</label>
                        <input type="text" id="batch-property-value" class="form-input" required>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">应用范围</label>
                        <div class="flex flex-wrap gap-4">
                            <label class="inline-flex items-center">
                                <input type="radio" name="batch-scope" value="all" class="form-radio text-primary" checked>
                                <span class="ml-2 text-gray-300">所有节点</span>
                            </label>
                            <label class="inline-flex items-center">
                                <input type="radio" name="batch-scope" value="selected" class="form-radio text-primary">
                                <span class="ml-2 text-gray-300">仅选中节点</span>
                            </label>
                            <label class="inline-flex items-center">
                                <input type="radio" name="batch-scope" value="level" class="form-radio text-primary">
                                <span class="ml-2 text-gray-300">特定层级</span>
                            </label>
                        </div>
                    </div>
                    
                    <div id="level-selector" class="form-group hidden">
                        <label for="batch-level" class="form-label">层级</label>
                        <input type="number" id="batch-level" class="form-input" min="0">
                    </div>
                    
                    <div class="flex justify-end space-x-4 mt-6">
                        <button type="button" id="btn-cancel-batch" class="px-4 py-2 border border-gray-700 rounded-md text-gray-300 hover:bg-gray-800">取消</button>
                        <button type="submit" class="btn-action btn-primary">应用</button>
                    </div>
                </form>
            </div>
        </div>
        
        <!-- Node Type Manager (Hidden by default) -->
        <div id="type-manager" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
            <div class="bg-surface rounded-lg shadow-xl p-6 w-full max-w-2xl border border-gray-700">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl font-semibold text-white">节点类型管理</h2>
                    <button id="btn-close-type-manager" class="text-gray-400 hover:text-white">
                        <i class="fa fa-times text-xl"></i>
                    </button>
                </div>
                
                <div class="mb-4">
                    <div class="flex justify-between items-center mb-2">
                        <h3 class="font-medium text-gray-300">现有节点类型</h3>
                        <button id="btn-add-type" class="px-3 py-1 text-sm bg-green-900 text-green-300 rounded-md hover:bg-green-800">
                            <i class="fa fa-plus mr-1"></i>添加类型
                        </button>
                    </div>
                    <div id="node-types-list" class="border border-gray-700 rounded-md p-2 max-h-40 overflow-y-auto bg-darker">
                        <!-- Node types will be added here dynamically -->
                    </div>
                </div>
                
                <div class="mb-4">
                    <div class="flex justify-between items-center mb-2">
                        <h3 class="font-medium text-gray-300">现有关系类型</h3>
                        <button id="btn-add-relationship-type" class="px-3 py-1 text-sm bg-green-900 text-green-300 rounded-md hover:bg-green-800">
                            <i class="fa fa-plus mr-1"></i>添加关系类型
                        </button>
                    </div>
                    <div id="relationship-types-list" class="border border-gray-700 rounded-md p-2 max-h-40 overflow-y-auto bg-darker">
                        <!-- Relationship types will be added here dynamically -->
                    </div>
                </div>
                
                <div class="flex justify-end">
                    <button id="btn-cancel-type-manager" class="px-4 py-2 border border-gray-700 rounded-md text-gray-300 hover:bg-gray-800">关闭</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let treeCy, networkCy;
        let selectedNodes = [];
        let currentNodeId = null;
        // 简单的加载检查
        window.addEventListener('load', function() {
            console.log('应用已加载');
        });
        
        // Neo4j connection settings (stored in localStorage)
        let neo4jConfig = {
            backendUrl: localStorage.getItem('neo4j_backendUrl') || 'http://localhost:8000',
            uri: localStorage.getItem('neo4j_uri') || 'bolt://localhost:7687',
            user: localStorage.getItem('neo4j_user') || 'neo4j',
            password: localStorage.getItem('neo4j_password') || '',
            database: localStorage.getItem('neo4j_database') || 'neo4j'
        };
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', async function() {
            initGraphs();
            setupEventListeners();
            // Don't auto-load data, user needs to connect first
        });
        
        // Initialize Cytoscape graphs
        function initGraphs() {
            // Initialize tree graph with hierarchical layout
            treeCy = cytoscape({
                container: document.getElementById('tree-graph'),
                elements: [],
                style: [
                    {
                        selector: 'node',
                        style: {
                            'background-color': '#3B82F6',
                            'label': 'data(name)',
                            'width': '60px',
                            'height': '60px',
                            'font-size': '12px',
                            'text-valign': 'center',
                            'text-halign': 'center',
                            'color': '#fff',
                            'border-width': '2px',
                            'border-color': '#2563EB',
                            'border-opacity': '1'
                        }
                    },
                    {
                        selector: 'node:selected',
                        style: {
                            'background-color': '#8B5CF6',
                            'border-color': '#7C3AED',
                            'border-width': '3px'
                        }
                    },
                    {
                        selector: 'edge',
                        style: {
                            'width': 3,
                            'line-color': '#10B981',
                            'target-arrow-color': '#10B981',
                            'target-arrow-shape': 'triangle',
                            'curve-style': 'bezier',
                            'label': 'data(label)',
                            'font-size': '10px',
                            'text-background-color': '#1F2937',
                            'text-background-opacity': 0.9,
                            'text-background-padding': '2px',
                            'text-background-shape': 'roundrectangle',
                            'color': '#E5E7EB'
                        }
                    },
                    {
                        selector: 'edge:selected',
                        style: {
                            'width': 4,
                            'line-color': '#8B5CF6',
                            'target-arrow-color': '#8B5CF6'
                        }
                    }
                ],
                layout: {
                    name: 'hierarchical',
                    direction: 'UD',
                    levelSeparation: 100,
                    nodeSeparation: 50,
                    treeSpacing: 50,
                    edgeMinimization: true,
                    parentCentralization: true,
                    padding: 30,
                    animate: true,
                    animationDuration: 500,
                    animationEasing: 'ease-out',
                    fit: true
                }
            });
            
            // Initialize network graph with cola layout
            networkCy = cytoscape({
                container: document.getElementById('network-graph'),
                elements: [],
                style: [
                    {
                        selector: 'node',
                        style: {
                            'background-color': '#8B5CF6',
                            'label': 'data(name)',
                            'width': '60px',
                            'height': '60px',
                            'font-size': '12px',
                            'text-valign': 'center',
                            'text-halign': 'center',
                            'color': '#fff',
                            'border-width': '2px',
                            'border-color': '#7C3AED',
                            'border-opacity': '1'
                        }
                    },
                    {
                        selector: 'node:selected',
                        style: {
                            'background-color': '#3B82F6',
                            'border-color': '#2563EB',
                            'border-width': '3px'
                        }
                    },
                    {
                        selector: 'edge',
                        style: {
                            'width': 3,
                            'line-color': '#EC4899',
                            'target-arrow-color': '#EC4899',
                            'target-arrow-shape': 'triangle',
                            'curve-style': 'bezier',
                            'label': 'data(label)',
                            'font-size': '10px',
                            'text-background-color': '#1F2937',
                            'text-background-opacity': 0.9,
                            'text-background-padding': '2px',
                            'text-background-shape': 'roundrectangle',
                            'color': '#E5E7EB'
                        }
                    },
                    {
                        selector: 'edge:selected',
                        style: {
                            'width': 4,
                            'line-color': '#3B82F6',
                            'target-arrow-color': '#3B82F6'
                        }
                    }
                ],
                layout: {
                    name: 'cola',
                    nodeSpacing: 100,
                    edgeLength: 150,
                    animate: true,
                    animationDuration: 500,
                    fit: true,
                    padding: 30
                }
            });
            
            // 确保window.selectedNodes存在并正确初始化
            if (!window.selectedNodes || !Array.isArray(window.selectedNodes)) {
                window.selectedNodes = [];
                console.log('NODE SELECTION: 初始化window.selectedNodes为空数组');
            }
            
            // 确保全局selectedNodes变量存在
            if (typeof selectedNodes === 'undefined') {
                window.selectedNodes = window.selectedNodes || [];
                selectedNodes = [...window.selectedNodes];
                console.log('NODE SELECTION: 创建全局selectedNodes变量并从window.selectedNodes复制');
            }
            
            // 强制同步selectedNodes和window.selectedNodes
            window.selectedNodes = [...selectedNodes];
            console.log('NODE SELECTION: 初始化完成 - selectedNodes长度:', selectedNodes.length);
            console.log('NODE SELECTION: 初始化完成 - window.selectedNodes长度:', window.selectedNodes.length);
            
            // 创建一个函数来同步两个选中节点列表
            function syncSelectedNodes() {
                selectedNodes = [...window.selectedNodes];
                console.log('NODE SELECTION: 执行强制同步 - selectedNodes与window.selectedNodes保持一致');
                console.log('NODE SELECTION: 同步后 - selectedNodes长度:', selectedNodes.length);
                console.log('NODE SELECTION: 同步后 - window.selectedNodes长度:', window.selectedNodes.length);
                console.log('NODE SELECTION: 同步后 - 选中的节点ID:', selectedNodes);
            }
            
            // Handle node selection in tree graph
            treeCy.on('select', 'node', function(evt) {
                console.log('===== 树图节点选中事件开始 =====');
                const node = evt.target;
                const nodeId = node.id();
                
                console.log('NODE SELECTION: 树图节点被选中:', nodeId);
                console.log('NODE SELECTION: 选中前 - selectedNodes:', selectedNodes);
                console.log('NODE SELECTION: 选中前 - window.selectedNodes:', window.selectedNodes);
                
                // 避免重复添加
                if (!selectedNodes.includes(nodeId)) {
                    selectedNodes.push(nodeId);
                    console.log('NODE SELECTION: 树图节点已添加到selectedNodes:', nodeId);
                }
                
                // 强制同步到window.selectedNodes
                window.selectedNodes = [...selectedNodes];
                console.log('NODE SELECTION: 选中后 - selectedNodes长度:', selectedNodes.length);
                console.log('NODE SELECTION: 选中后 - window.selectedNodes长度:', window.selectedNodes.length);
                console.log('NODE SELECTION: 选中后 - 选中的节点ID列表:', selectedNodes);
                
                // Sync selection with network graph
                const networkNode = networkCy.$(`#${node.id()}`);
                if (networkNode.length > 0) {
                    networkNode.select();
                    console.log('NODE SELECTION: 已同步选中网络图中的对应节点:', nodeId);
                }
                console.log('===== 树图节点选中事件结束 =====');
            });
            
            treeCy.on('unselect', 'node', function(evt) {
                console.log('===== 树图节点取消选中事件开始 =====');
                const node = evt.target;
                const nodeId = node.id();
                
                console.log('NODE SELECTION: 树图节点取消选中:', nodeId);
                console.log('NODE SELECTION: 取消前 - selectedNodes:', selectedNodes);
                
                selectedNodes = selectedNodes.filter(id => id !== nodeId);
                console.log('NODE SELECTION: 从selectedNodes移除节点:', nodeId);
                
                // 强制同步到window.selectedNodes
                window.selectedNodes = [...selectedNodes];
                console.log('NODE SELECTION: 取消后 - selectedNodes长度:', selectedNodes.length);
                console.log('NODE SELECTION: 取消后 - window.selectedNodes长度:', window.selectedNodes.length);
                console.log('NODE SELECTION: 取消后 - 剩余选中节点:', selectedNodes);
                
                // Sync selection with network graph
                const networkNode = networkCy.$(`#${node.id()}`);
                if (networkNode.length > 0) {
                    networkNode.unselect();
                    console.log('NODE SELECTION: 已同步取消选中网络图中的对应节点:', nodeId);
                }
                console.log('===== 树图节点取消选中事件结束 =====');
            });
            
            // Handle node selection in network graph
            networkCy.on('select', 'node', function(evt) {
                console.log('===== 网络图节点选中事件开始 =====');
                const node = evt.target;
                const nodeId = node.id();
                
                console.log('NODE SELECTION: 网络图节点被选中:', nodeId);
                console.log('NODE SELECTION: 选中前 - selectedNodes:', selectedNodes);
                console.log('NODE SELECTION: 选中前 - window.selectedNodes:', window.selectedNodes);
                
                // 避免重复添加
                if (!selectedNodes.includes(nodeId)) {
                    selectedNodes.push(nodeId);
                    console.log('NODE SELECTION: 网络图节点已添加到selectedNodes:', nodeId);
                }
                
                // 强制同步到window.selectedNodes
                window.selectedNodes = [...selectedNodes];
                console.log('NODE SELECTION: 选中后 - selectedNodes长度:', selectedNodes.length);
                console.log('NODE SELECTION: 选中后 - window.selectedNodes长度:', window.selectedNodes.length);
                console.log('NODE SELECTION: 选中后 - 选中的节点ID列表:', selectedNodes);
                
                // Sync selection with tree graph
                const treeNode = treeCy.$(`#${node.id()}`);
                if (treeNode.length > 0) {
                    treeNode.select();
                    console.log('NODE SELECTION: 已同步选中树图中的对应节点:', nodeId);
                }
                console.log('===== 网络图节点选中事件结束 =====');
            });
            
            networkCy.on('unselect', 'node', function(evt) {
                console.log('===== 网络图节点取消选中事件开始 =====');
                const node = evt.target;
                const nodeId = node.id();
                
                console.log('NODE SELECTION: 网络图节点取消选中:', nodeId);
                console.log('NODE SELECTION: 取消前 - selectedNodes:', selectedNodes);
                
                selectedNodes = selectedNodes.filter(id => id !== nodeId);
                console.log('NODE SELECTION: 从selectedNodes移除节点:', nodeId);
                
                // 强制同步到window.selectedNodes
                window.selectedNodes = [...selectedNodes];
                console.log('NODE SELECTION: 取消后 - selectedNodes长度:', selectedNodes.length);
                console.log('NODE SELECTION: 取消后 - window.selectedNodes长度:', window.selectedNodes.length);
                console.log('NODE SELECTION: 取消后 - 剩余选中节点:', selectedNodes);
                
                // Sync selection with tree graph
                const treeNode = treeCy.$(`#${node.id()}`);
                if (treeNode.length > 0) {
                    treeNode.unselect();
                    console.log('NODE SELECTION: 已同步取消选中树图中的对应节点:', nodeId);
                }
                console.log('===== 网络图节点取消选中事件结束 =====');
            });
            
            // 实现syncSelectedNodes函数并挂载到window对象
            function syncSelectedNodes() {
                console.log('NODE SELECTION: 执行syncSelectedNodes函数');
                
                // 确保selectedNodes变量存在
                if (typeof selectedNodes === 'undefined') {
                    console.error('NODE SELECTION: selectedNodes变量未定义，正在初始化');
                    window.selectedNodes = window.selectedNodes || [];
                    selectedNodes = [...window.selectedNodes];
                    console.log('NODE SELECTION: 初始化后 - selectedNodes长度:', selectedNodes.length);
                    return;
                }
                
                // 确保window.selectedNodes存在
                if (!window.selectedNodes) {
                    console.warn('NODE SELECTION: window.selectedNodes不存在，正在初始化');
                    window.selectedNodes = [...selectedNodes];
                    console.log('NODE SELECTION: window.selectedNodes初始化后长度:', window.selectedNodes.length);
                    return;
                }
                
                // 执行深拷贝同步
                if (JSON.stringify(selectedNodes) !== JSON.stringify(window.selectedNodes)) {
                    console.log('NODE SELECTION: 检测到不同步，正在执行同步');
                    selectedNodes = JSON.parse(JSON.stringify(window.selectedNodes));
                    console.log('NODE SELECTION: 同步后 - selectedNodes长度:', selectedNodes.length);
                    console.log('NODE SELECTION: 同步后 - window.selectedNodes长度:', window.selectedNodes.length);
                    console.log('NODE SELECTION: 同步后 - 选中的节点ID:', selectedNodes);
                } else {
                    console.log('NODE SELECTION: 执行强制同步 - selectedNodes与window.selectedNodes保持一致');
                    console.log('NODE SELECTION: 同步后 - selectedNodes长度:', selectedNodes.length);
                    console.log('NODE SELECTION: 同步后 - window.selectedNodes长度:', window.selectedNodes.length);
                    console.log('NODE SELECTION: 同步后 - 选中的节点ID:', selectedNodes);
                }
            }
            
            // 将syncSelectedNodes函数挂载到window对象，确保全局可访问
            window.syncSelectedNodes = syncSelectedNodes;
            
            // 为按钮点击事件添加同步检查
            document.addEventListener('click', function(e) {
                // 当点击任何按钮时，先强制同步
                if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
                    window.syncSelectedNodes();
                }
            }, true); // 使用捕获阶段，确保先执行
            
            // Handle double click on nodes to edit properties
            treeCy.on('dblclick', 'node', function(evt) {
                const node = evt.target;
                openPropertyEditor(node.id());
            });
            
            networkCy.on('dblclick', 'node', function(evt) {
                const node = evt.target;
                openPropertyEditor(node.id());
            });
        }
        
        // Setup event listeners for UI elements
        function setupEventListeners() {
            // Neo4j Connection button
            document.getElementById('btn-connect').addEventListener('click', function() {
                openNeo4jConnectionDialog();
            });
            
            // Close Neo4j Connection dialog
            document.getElementById('btn-close-connection').addEventListener('click', function() {
                document.getElementById('neo4j-connection-dialog').classList.add('hidden');
            });
            
            document.getElementById('btn-cancel-connection').addEventListener('click', function() {
                document.getElementById('neo4j-connection-dialog').classList.add('hidden');
            });
            
            // Test Neo4j connection
            document.getElementById('btn-test-connection').addEventListener('click', async function() {
                await testNeo4jConnection();
            });
            
            // Save Neo4j connection settings
            document.getElementById('neo4j-connection-form').addEventListener('submit', function(e) {
                e.preventDefault();
                saveNeo4jConnectionSettings();
            });
            
            // Add Node button
            document.getElementById('btn-add-node').addEventListener('click', function() {
                openPropertyEditor();
            });
            
            // Delete Node button
            document.getElementById('btn-delete-node').addEventListener('click', function() {
                if (selectedNodes.length > 0) {
                    if (confirm(`确定要删除选中的 ${selectedNodes.length} 个节点吗？`)) {
                        deleteNodes(selectedNodes);
                    }
                } else {
                    alert('请先选择要删除的节点');
                }
            });
            
            // Add Parent button
            document.getElementById('btn-add-parent').addEventListener('click', function() {
                console.log('===== 设置父节点按钮点击事件开始 =====');
                console.log('设置父节点按钮点击，当前selectedNodes:', selectedNodes, '长度:', selectedNodes.length);
                console.log('window.selectedNodes:', window.selectedNodes, '长度:', window.selectedNodes?.length);
                
                // 使用window.syncSelectedNodes函数确保同步
                window.syncSelectedNodes();
                console.log('调用window.syncSelectedNodes后 - selectedNodes:', selectedNodes, '长度:', selectedNodes.length);
                console.log('调用window.syncSelectedNodes后 - window.selectedNodes:', window.selectedNodes, '长度:', window.selectedNodes?.length);
                
                if (selectedNodes.length === 2) {
                    const childId = selectedNodes[0];
                    const parentId = selectedNodes[1];
                    console.log('设置父节点:', { childId, parentId });
                    addParent(childId, parentId);
                } else {
                    console.error('选择节点数量不足，需要2个节点');
                    alert('请选择两个节点，第一个作为子节点，第二个作为父节点');
                }
                console.log('===== 设置父节点按钮点击事件结束 =====');
            });
            
            // Remove Parent button
            document.getElementById('btn-remove-parent').addEventListener('click', function() {
                if (selectedNodes.length === 1) {
                    const nodeId = selectedNodes[0];
                    removeParent(nodeId);
                } else {
                    alert('请选择一个节点以移除其父节点');
                }
            });
            
            // Add Connection button
            document.getElementById('btn-add-connection').addEventListener('click', function() {
                console.log('===== 添加连接按钮点击事件开始 =====');
                console.log('添加连接按钮点击，当前selectedNodes:', selectedNodes, '长度:', selectedNodes.length);
                console.log('window.selectedNodes:', window.selectedNodes, '长度:', window.selectedNodes?.length);
                
                // 使用syncSelectedNodes函数确保同步
                syncSelectedNodes();
                console.log('调用syncSelectedNodes后 - selectedNodes:', selectedNodes, '长度:', selectedNodes.length);
                console.log('调用syncSelectedNodes后 - window.selectedNodes:', window.selectedNodes, '长度:', window.selectedNodes?.length);
                
                if (selectedNodes.length >= 2) {
                    console.log('添加同级连接节点:', selectedNodes);
                    addConnections(selectedNodes);
                } else {
                    console.error('选择节点数量不足，需要至少2个节点');
                    alert('请选择至少两个节点以创建同级连接');
                }
                console.log('===== 添加连接按钮点击事件结束 =====');
            });
            
            // Remove Connection button
            document.getElementById('btn-remove-connection').addEventListener('click', function() {
                if (selectedNodes.length >= 2) {
                    removeConnections(selectedNodes);
                } else {
                    alert('请选择至少两个节点以移除同级连接');
                }
            });
            
            // Batch Update button
            document.getElementById('btn-batch-update').addEventListener('click', function() {
                document.getElementById('batch-update').classList.remove('hidden');
            });
            
            // Save button
            document.getElementById('btn-save').addEventListener('click', function() {
                saveData();
            });
            
            // Load button
            document.getElementById('btn-load').addEventListener('click', function() {
                loadData();
            });
            
            // Close Property Editor buttons
            document.getElementById('btn-close-editor').addEventListener('click', function() {
                document.getElementById('property-editor').classList.add('hidden');
            });
            
            document.getElementById('btn-cancel-editor').addEventListener('click', function() {
                document.getElementById('property-editor').classList.add('hidden');
            });
            
            // Close Batch Update buttons
            document.getElementById('btn-close-batch').addEventListener('click', function() {
                document.getElementById('batch-update').classList.add('hidden');
            });
            
            document.getElementById('btn-cancel-batch').addEventListener('click', function() {
                document.getElementById('batch-update').classList.add('hidden');
            });
            
            // Property Form submission
            document.getElementById('property-form').addEventListener('submit', function(e) {
                e.preventDefault();
                saveNodeProperties();
            });
            
            // Batch Form submission
            document.getElementById('batch-form').addEventListener('submit', function(e) {
                e.preventDefault();
                batchUpdateProperties();
            });
            
            // Batch scope radio buttons
            document.querySelectorAll('input[name="batch-scope"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    if (this.value === 'level') {
                        document.getElementById('level-selector').classList.remove('hidden');
                    } else {
                        document.getElementById('level-selector').classList.add('hidden');
                    }
                });
            });
        }
        
        // Open property editor for a node (or new node)
        function openPropertyEditor(nodeId = null) {
            const editor = document.getElementById('property-editor');
            const title = document.getElementById('editor-title');
            const form = document.getElementById('property-form');
            
            // Reset form
            form.reset();
            
            if (nodeId) {
                // Edit existing node
                title.textContent = '编辑节点属性';
                document.getElementById('node-id').value = nodeId;
                
                // Get node data from tree graph (both graphs have the same nodes)
                const node = treeCy.$(`#${nodeId}`);
                if (node.length > 0) {
                    document.getElementById('node-name').value = node.data('name') || '';
                    document.getElementById('node-type').value = node.data('type') || '';
                    document.getElementById('node-level').value = node.data('level') || 0;
                    
                    // Convert properties object to JSON string
                    const properties = node.data('properties') || {};
                    document.getElementById('node-properties').value = JSON.stringify(properties, null, 2);
                }
            } else {
                // Add new node
                title.textContent = '添加新节点';
                document.getElementById('node-id').value = '';
                document.getElementById('node-level').value = 0;
                document.getElementById('node-properties').value = '{}';
            }
            
            // Show editor
            editor.classList.remove('hidden');
        }
        
        // Save node properties (add or update)
        async function saveNodeProperties() {
            const nodeId = document.getElementById('node-id').value;
            const name = document.getElementById('node-name').value;
            const type = document.getElementById('node-type').value;
            let level = parseInt(document.getElementById('node-level').value);
            
            // Parse properties JSON
            let properties = {};
            try {
                properties = JSON.parse(document.getElementById('node-properties').value);
            } catch (e) {
                alert('无效的JSON格式');
                return;
            }
            
            // 创建不含level的基础节点数据
            const baseNodeData = {
                id: nodeId || `node-${Date.now()}`,
                name,
                type,
                properties
            };
            
            if (nodeId) {
                // 更新现有节点
                // 从树结构中重新计算层级
                const treeNode = treeCy.$(`#${nodeId}`);
                if (treeNode.length > 0) {
                    // 获取所有指向该节点的父节点关系
                    const incomingEdges = treeCy.edges(`edge[target = "${nodeId}"][label = "PARENT_OF"]`);
                    if (incomingEdges.length > 0) {
                        // 如果有父节点，层级是父节点层级+1
                        const parentNode = treeCy.$(`#${incomingEdges.first().data('source')}`);
                        if (parentNode.length > 0) {
                            level = calculateNodeLevel(parentNode.data('id')) + 1;
                        }
                    } else {
                        // 没有父节点，层级为0
                        level = 0;
                    }
                }
                
                // 更新节点数据，包含重新计算的层级
                const nodeData = {
                    ...baseNodeData,
                    level
                };
                
                // 直接更新树图中的节点属性
                if (treeNode.length > 0) {
                    treeNode.data('name', nodeData.name);
                    treeNode.data('type', nodeData.type);
                    treeNode.data('level', nodeData.level);
                    treeNode.data('properties', nodeData.properties);
                    console.log('成功更新树图中的节点数据:', nodeId, nodeData);
                }
                
                // 更新两个图
                updateNodeInGraphs(nodeData);
                
                // 更新Neo4j
                await updateNodeInNeo4j(nodeData);
                
                // 重新同步网络图，只显示相同层级的节点
                syncNetworkWithTreeLevel(level);
            } else {
                // 添加新节点
                const newNodeId = baseNodeData.id;
                
                // 创建包含层级的完整节点数据
                const newNodeData = {
                    ...baseNodeData,
                    level: level
                };
                
                console.log('创建新节点数据:', newNodeData);
                
                // 首先添加到树图，确保属性正确设置
                addNodeToTreeGraph(newNodeData, level);
                
                // 额外确保节点属性正确设置在树图中
                const treeNode = treeCy.$(`#${newNodeId}`);
                if (treeNode.length > 0) {
                    treeNode.data('name', newNodeData.name);
                    treeNode.data('type', newNodeData.type);
                    treeNode.data('level', newNodeData.level);
                    treeNode.data('properties', newNodeData.properties);
                    console.log('额外确认树图中的节点属性设置:', newNodeId);
                }
                
                // 添加到Neo4j
                await addNodeToNeo4j(newNodeData);
                
                // 如果level > 0，查找前一层级的父节点
                if (level > 0) {
                    const potentialParents = getNodesByLevel(level - 1);
                    if (potentialParents.length > 0) {
                        const parentId = potentialParents[0];
                        addParentToGraphs(newNodeId, parentId);
                        await addParentInNeo4j(newNodeId, parentId);
                    }
                }
                
                // 同步网络图，只显示相同层级的节点
                syncNetworkWithTreeLevel(level);
            }
            
            // 关闭编辑器
            document.getElementById('property-editor').classList.add('hidden');
        }
        
        // 计算节点在树中的层级
        function calculateNodeLevel(nodeId) {
            let level = 0;
            let currentId = nodeId;
            
            // 向上遍历直到根节点
            while (true) {
                const incomingEdges = treeCy.edges(`edge[target = "${currentId}"][label = "PARENT_OF"]`);
                if (incomingEdges.length === 0) {
                    break;
                }
                
                // 避免使用first()方法，直接访问数组元素
                // 假设edges()返回的对象可以通过索引访问或转换为数组
                let edge;
                if (incomingEdges[0]) {
                    edge = incomingEdges[0];
                } else if (incomingEdges.toArray) {
                    const edgeArray = incomingEdges.toArray();
                    if (edgeArray.length > 0) {
                        edge = edgeArray[0];
                    }
                }
                
                if (edge && edge.data) {
                    currentId = edge.data('source');
                    level++;
                } else {
                    break;
                }
            }
            
            return level;
        }
        
        // 获取指定层级的所有节点ID
        function getNodesByLevel(level) {
            const allNodes = treeCy.nodes('node').toArray();
            const levelNodes = [];
            
            allNodes.forEach(node => {
                const nodeLevel = calculateNodeLevel(node.id());
                if (nodeLevel === level) {
                    levelNodes.push(node.id());
                }
            });
            
            return levelNodes;
        }
        
        // 同步网络图显示特定层级的节点
        function syncNetworkWithTreeLevel(level) {
            console.log('==========================');
            console.log('开始同步网络图与树图层级:', level);
            console.log('当前网络图中的节点数量在清除前:', networkCy.nodes().length);
            console.log('当前网络图中的边数量在清除前:', networkCy.edges().length);
            
            // 清除网络图中的所有元素 - 明确区分节点和边
            console.log('开始清除网络图中的所有节点...');
            networkCy.remove('node');
            console.log('节点清除后，网络图中剩余节点数量:', networkCy.nodes().length);
            
            console.log('开始清除网络图中的所有边...');
            networkCy.remove('edge');
            console.log('边清除后，网络图中剩余边数量:', networkCy.edges().length);
            
            // 验证清除操作是否成功
            if (networkCy.nodes().length > 0 || networkCy.edges().length > 0) {
                console.error('警告: 网络图清除操作未完全成功!');
                // 强制再次清除
                networkCy.remove('*');
                console.log('强制再次清除后 - 节点数量:', networkCy.nodes().length);
                console.log('强制再次清除后 - 边数量:', networkCy.edges().length);
            }
            
            // 获取指定层级的所有节点
            console.log('获取层级', level, '的节点');
            const levelNodeIds = getNodesByLevel(level);
            console.log('层级', level, '的节点数量:', levelNodeIds.length);
            console.log('层级', level, '的节点ID列表:', levelNodeIds);
            
            // 添加该层级的所有节点到网络图
            console.log('开始添加层级', level, '的节点到网络图');
            let addedNodeCount = 0;
            const uniqueNodeIds = new Set(); // 用于检测重复节点
            
            levelNodeIds.forEach(nodeId => {
                // 检查节点ID是否唯一
                if (uniqueNodeIds.has(nodeId)) {
                    console.warn('发现重复节点ID:', nodeId, '将被跳过');
                    return;
                }
                
                try {
                    const treeNode = treeCy.$(`#${nodeId}`);
                    console.log('从树图查询节点:', nodeId, '节点对象存在:', treeNode.length > 0);
                    
                    // 定义nodeData变量
                    let nodeData = null;
                    
                    if (treeNode.length > 0) {
                        // 直接获取节点的各个属性，而不是依赖data()返回完整对象
                        const nodeName = treeNode.data('name');
                        const nodeType = treeNode.data('type');
                        const nodeLevel = treeNode.data('level');
                        const nodeProperties = treeNode.data('properties');
                         
                        console.log('从树图获取节点属性:', nodeId, 'name:', nodeName, 'type:', nodeType, 'level:', nodeLevel);
                         
                        // 构建节点数据对象
                        nodeData = {
                            id: nodeId,
                            name: nodeName || `节点-${nodeId.substring(0, 8)}`,
                            type: nodeType || 'default',
                            level: typeof nodeLevel === 'number' ? nodeLevel : level,
                            properties: nodeProperties || {}
                        };
                         
                        console.log('构建的节点数据对象:', nodeData);
                     
                        // 更健壮地检查网络图中是否已存在该节点
                        try {
                            const existingNode = networkCy.$(`#${nodeId}`);
                            if (existingNode && existingNode.length > 0) {
                                console.warn('节点已存在于网络图中:', nodeId, '将被跳过');
                                // 即使节点已存在，也将其添加到唯一ID集合中，以便正确计数
                                uniqueNodeIds.add(nodeId);
                                // 在forEach回调中使用return来跳过当前迭代
                                return;
                            }
                            
                            // 添加节点到网络图
                            networkCy.add({
                                group: 'nodes',
                                data: nodeData
                            });
                            addedNodeCount++;
                            uniqueNodeIds.add(nodeId);
                            console.log('成功添加节点到网络图:', nodeData.name || nodeData.id, '数量:', addedNodeCount);
                        } catch (error) {
                            console.error('处理节点时发生错误:', nodeId, '错误:', error);
                            // 即使添加失败，也尝试将节点ID添加到唯一集合中，以便跟踪已处理的节点
                            uniqueNodeIds.add(nodeId);
                        }
                    } else {
                        console.warn('树图中未找到节点:', nodeId);
                    }
                } catch (error) {
                    console.error('处理节点时发生错误:', nodeId, '错误:', error);
                }
            });
            
            console.log('成功添加到网络图的节点数量:', addedNodeCount);
            // 更可靠地获取节点数量
            let currentNodeCount = 0;
            try {
                const nodes = networkCy.nodes();
                currentNodeCount = nodes ? (Array.isArray(nodes) || typeof nodes.length === 'number' ? nodes.length : 0) : 0;
            } catch (err) {
                console.error('获取节点数量时发生错误:', err);
                currentNodeCount = 0;
            }
            console.log('当前网络图中的节点数量:', currentNodeCount);
            console.log('唯一节点ID集合大小:', uniqueNodeIds.size);
            
            // 验证添加的节点数量是否正确（考虑到可能有重复节点被跳过）
            if (addedNodeCount !== uniqueNodeIds.size) {
                console.warn('添加的节点数量与唯一节点ID集合大小不匹配! 可能存在计数问题');
            } else if (addedNodeCount === 0 && levelNodeIds.length > 0) {
                console.warn('未添加任何节点，但层级中有节点! 可能存在节点添加逻辑问题');
            }
            
            // 只添加该层级内部节点之间的连接，不调用addConnectionsToGraphs避免添加额外节点
            if (levelNodeIds.length > 1) {
                console.log('开始创建层级内部节点之间的连接');
                let addedEdgeCount = 0;
                const uniqueEdgeIds = new Set(); // 用于检测重复连接
                
                // 创建所有可能的双向连接
                for (let i = 0; i < levelNodeIds.length; i++) {
                    for (let j = i + 1; j < levelNodeIds.length; j++) {
                        const source = levelNodeIds[i];
                        const target = levelNodeIds[j];
                        const edgeId = `edge_${source}_${target}`;
                        
                        // 检查连接ID是否唯一
                        if (uniqueEdgeIds.has(edgeId)) {
                            console.warn('发现重复连接ID:', edgeId, '将被跳过');
                            continue;
                        }
                        
                        // 检查源节点和目标节点是否都存在于网络图中
                        const sourceNode = networkCy.$(`#${source}`);
                        const targetNode = networkCy.$(`#${target}`);
                        
                        if (sourceNode.length === 0 || targetNode.length === 0) {
                            console.warn('连接创建失败: 源节点或目标节点不存在于网络图中 - 源:', source, '目标:', target);
                            continue;
                        }
                        
                        // 检查连接是否已存在
                        const existingEdge = networkCy.$(`#${edgeId}`);
                        if (existingEdge.length > 0) {
                            console.warn('连接已存在于网络图中:', edgeId, '将被跳过');
                            continue;
                        }
                        
                        // 添加双向连接
                        try {
                            networkCy.add({
                                group: 'edges',
                                data: {
                                    id: edgeId,
                                    source: source,
                                    target: target,
                                    label: 'CONNECTED_TO'
                                }
                            });
                            uniqueEdgeIds.add(edgeId);
                            addedEdgeCount++;
                            console.log('添加连接:', edgeId, '从', source, '(', sourceNode.data('name'), ') 到', target, '(', targetNode.data('name'), ')');
                        } catch (error) {
                            console.error('添加连接时出错:', edgeId, error.message);
                        }
                    }
                }
                
                console.log('成功添加的连接数量:', addedEdgeCount);
                
                // 添加树图中的父节点关系到网络图
                console.log('开始添加树图中的父节点关系到网络图');
                let addedParentEdges = 0;
                const parentEdgeSet = new Set();
                
                try {
                    // 获取树图中所有父节点关系
                    const treeEdges = treeCy.edges('[label = "PARENT_OF"]');
                    console.log('树图中父节点关系数量:', treeEdges ? treeEdges.length : 0);
                    
                    // 安全地迭代cytoscape集合对象
                    if (treeEdges && typeof treeEdges.forEach === 'function') {
                        treeEdges.forEach(edge => {
                            try {
                                const sourceId = edge.data('source');
                                const targetId = edge.data('target');
                                const edgeId = `tree-relationship-${sourceId}-${targetId}`;
                                
                                // 检查连接ID是否唯一
                                if (parentEdgeSet.has(edgeId)) {
                                    console.warn('发现重复父节点关系ID:', edgeId, '将被跳过');
                                    return;
                                }
                                
                                // 检查源节点和目标节点是否都存在于网络图中
                                const sourceNode = networkCy.$(`#${sourceId}`);
                                const targetNode = networkCy.$(`#${targetId}`);
                                
                                if (sourceNode.length === 0 || targetNode.length === 0) {
                                    console.log('跳过父节点关系 - 源节点或目标节点不在网络图中:', edgeId);
                                    return;
                                }
                                
                                // 检查连接是否已存在
                                const existingEdge = networkCy.$(`#${edgeId}`);
                                if (existingEdge.length > 0) {
                                    console.warn('父节点关系已存在于网络图中:', edgeId, '将被跳过');
                                    return;
                                }
                                
                                // 添加父节点关系到网络图 - 简化结构
                                networkCy.add({
                                    group: 'edges',
                                    data: {
                                        id: edgeId,
                                        source: sourceId,
                                        target: targetId,
                                        label: 'PARENT_OF'
                                    }
                                });
                                
                                parentEdgeSet.add(edgeId);
                                addedParentEdges++;
                                console.log('添加父节点关系到网络图:', edgeId, '从', sourceId, '到', targetId);
                            } catch (error) {
                                console.error('添加父节点关系时出错:', error.message);
                            }
                        });
                    } else {
                        console.log('树图关系对象不支持forEach方法，跳过父节点关系添加');
                    }
                } catch (err) {
                    console.error('获取或处理树图父节点关系时发生错误:', err.message);
                }
                
                console.log('成功添加的父节点关系数量:', addedParentEdges);
                
                // 安全地获取边数量
                const currentEdgeCount = networkCy.edges() && typeof networkCy.edges().length === 'number' ? networkCy.edges().length : 0;
                console.log('当前网络图中的边数量:', currentEdgeCount);
                console.log('唯一连接ID集合大小:', uniqueEdgeIds.size);
                
                // 验证添加的连接数量是否正确
                const expectedEdges = (levelNodeIds.length * (levelNodeIds.length - 1)) / 2;
                if (addedEdgeCount !== expectedEdges) {
                    console.warn('添加的连接数量与预期不匹配! 预期:', expectedEdges, '实际:', addedEdgeCount);
                }
            } else {
                console.log('节点数量不足，不需要创建连接');
            }
            
            // 运行布局
            console.log('运行网络图布局');
            networkCy.layout().run();
            console.log('网络图同步完成');
            console.log('==========================');
        }
        
        // 批量更新属性
        async function batchUpdateProperties() {
            const key = document.getElementById('batch-property-key').value;
            const value = document.getElementById('batch-property-value').value;
            const scope = document.querySelector('input[name="batch-scope"]:checked').value;
            
            let nodesToUpdate = [];
            
            if (scope === 'all') {
                // 所有节点
                nodesToUpdate = treeCy.nodes().map(node => node.id());
            } else if (scope === 'selected') {
                // 选中的节点
                nodesToUpdate = selectedNodes;
            } else if (scope === 'level') {
                // 指定层级的节点
                const targetLevel = parseInt(document.getElementById('batch-level').value);
                // 使用calculateNodeLevel函数计算每个节点的实际层级
                nodesToUpdate = treeCy.nodes().map(node => {
                    if (calculateNodeLevel(node.id()) === targetLevel) {
                        return node.id();
                    }
                    return null;
                }).filter(id => id !== null);
            }
            
            if (nodesToUpdate.length === 0) {
                alert('没有找到符合条件的节点');
                return;
            }
            
            // 更新两个图中的节点
            for (const nodeId of nodesToUpdate) {
                const node = treeCy.$(`#${nodeId}`);
                if (node.length > 0) {
                    const properties = node.data('properties') || {};
                    properties[key] = value;
                    
                    // 更新树图中的节点
                    node.data('properties', properties);
                    
                    // 更新网络图中的节点（如果存在）
                    const networkNode = networkCy.$(`#${nodeId}`);
                    if (networkNode.length > 0) {
                        networkNode.data('properties', properties);
                    }
                }
            }
            
            // 更新Neo4j
            await batchUpdateInNeo4j(nodesToUpdate, key, value);
            
            // 关闭批量更新对话框
            document.getElementById('batch-update').classList.add('hidden');
            
            alert(`成功更新了 ${nodesToUpdate.length} 个节点的属性`);
        }
        
        // 添加节点到树图
        function addNodeToTreeGraph(nodeData, level) {
            // 添加到树图，包含层级信息
            treeCy.add({
                group: 'nodes',
                data: {
                    ...nodeData,
                    level: level
                }
            });
            
            // 更新树图布局
            treeCy.layout().run();
        }
        
        // 更新节点在两个图中
        function updateNodeInGraphs(nodeData) {
            // 更新树图中的节点
            const treeNode = treeCy.$(`#${nodeData.id}`);
            if (treeNode.length > 0) {
                treeNode.data({
                    name: nodeData.name,
                    type: nodeData.type,
                    level: nodeData.level,
                    properties: nodeData.properties
                });
            }
            
            // 更新网络图中的节点（如果存在）
            const networkNode = networkCy.$(`#${nodeData.id}`);
            if (networkNode.length > 0) {
                networkNode.data({
                    name: nodeData.name,
                    type: nodeData.type,
                    level: nodeData.level,
                    properties: nodeData.properties
                });
            }
            
            // 更新布局
            treeCy.layout().run();
            networkCy.layout().run();
        }
        
        // 原有函数已替换，这里不再需要
        // Update node in both graphs
        // 该函数已被上方的新实现替代
        
        // 删除节点
        function deleteNodes(nodeIds) {
            // 记录被删除节点的层级，用于后续更新网络图
            const deletedLevels = new Set();
            
            nodeIds.forEach(nodeId => {
                const node = treeCy.$(`#${nodeId}`);
                if (node.length > 0) {
                    // 计算并记录节点层级
                    const level = calculateNodeLevel(nodeId);
                    deletedLevels.add(level);
                    
                    // 删除与该节点相关的所有边
                    treeCy.remove(`edge[source = "${nodeId}"]`);
                    treeCy.remove(`edge[target = "${nodeId}"]`);
                }
            });
            
            // 从树图中删除节点
            treeCy.remove(`#${nodeIds.join(',#')}`);
            
            // 从网络图中删除节点
            networkCy.remove(`#${nodeIds.join(',#')}`);
            
            // 清除选中节点
            selectedNodes = [];
            
            // 更新树图布局
            treeCy.layout().run();
            
            // 重新同步受影响的层级到网络图
            if (networkCy.nodes().length > 0) {
                // 获取网络图中第一个节点的层级
                const currentLevel = calculateNodeLevel(networkCy.nodes().first().data('id'));
                syncNetworkWithTreeLevel(currentLevel);
            }
            
            // 从Neo4j删除
            deleteNodesFromNeo4j(nodeIds);
        }
        
        // 添加父节点关系
        function addParentToGraphs(childId, parentId) {
            // 记录原始ID用于调试
            console.log('添加父节点关系 - 原始childId:', childId, '原始parentId:', parentId);
            
            // 验证childId和parentId是有效的节点ID格式
            if (!childId || typeof childId !== 'string' || !childId.startsWith('node-')) {
                console.error('错误: childId不是有效的节点ID:', childId);
                return;
            }
            if (!parentId || typeof parentId !== 'string' || !parentId.startsWith('node-')) {
                console.error('错误: parentId不是有效的节点ID:', parentId);
                return;
            }
            
            // 确保子节点和父节点都存在于树图中
            const childNode = treeCy.$(`#${childId}`);
            const parentNode = treeCy.$(`#${parentId}`);
            
            if (childNode.length === 0) {
                console.error('错误: 子节点不存在于树图中:', childId);
                return;
            }
            if (parentNode.length === 0) {
                console.error('错误: 父节点不存在于树图中:', parentId);
                return;
            }
            
            // 移除子节点现有的父节点关系
            const existingEdges = treeCy.$(`edge[target = "${childId}"][label = "PARENT_OF"]`);
            console.log('找到现有的父节点关系数量:', existingEdges.length);
            if (existingEdges.length > 0) {
                treeCy.remove(existingEdges);
                console.log('已移除现有的父节点关系');
            }
            
            // 确保不会创建重复的边
            const edgeId = `tree-relationship-${parentId}-${childId}`;
            const existingEdge = treeCy.$(`#${edgeId}`);
            if (existingEdge.length > 0) {
                console.warn('警告: 边已存在，不重复添加:', edgeId);
                return;
            }
            
            // 构建边对象 - 简化结构，确保符合Cytoscape边的标准格式
            const edgeObject = {
                group: 'edges', // 明确指定是边而不是节点
                data: {
                    id: edgeId,
                    source: parentId,
                    target: childId,
                    label: 'PARENT_OF'
                    // 移除可能导致误解的额外属性
                }
            };
            
            console.log('准备添加边对象:', edgeObject);
            
            try {
                // 只添加边，不添加节点
                treeCy.add(edgeObject);
                console.log('成功添加关系:', edgeId, '从', parentId, '到', childId);
                
                // 验证边是否成功添加
                const addedEdge = treeCy.$(`#${edgeId}`);
                if (addedEdge.length > 0) {
                    console.log('边添加验证成功，元素类型:', addedEdge.data('type'), '元素组:', addedEdge.group());
                } else {
                    console.error('边添加验证失败，未找到添加的边:', edgeId);
                }
            } catch (error) {
                console.error('添加边时发生错误:', error);
            }
            
            // 重新计算并更新子节点的层级
            updateNodeHierarchy(childId);
            
            // 更新树图布局
            treeCy.layout().run();
            
            // 重新同步网络图
            try {
                // 获取子节点的层级，而不是依赖网络图中的节点
                const childNode = treeCy.$(`#${childId}`);
                if (childNode && childNode.length > 0) {
                    const childLevel = calculateNodeLevel(childId);
                    console.log('同步网络图层级:', childLevel, '使用子节点:', childId);
                    syncNetworkWithTreeLevel(childLevel);
                } else if (networkCy.nodes().length > 0) {
                    // 如果找不到子节点，但网络图不为空，则使用网络图中第一个节点的层级
                    const firstNode = networkCy.nodes()[0];
                    if (firstNode) {
                        const firstNodeId = firstNode.data('id');
                        const currentLevel = calculateNodeLevel(firstNodeId);
                        console.log('同步网络图层级:', currentLevel, '使用节点:', firstNodeId);
                        syncNetworkWithTreeLevel(currentLevel);
                    }
                }
            } catch (error) {
                console.error('同步网络图时发生错误:', error);
            }
        }
        
        // 更新节点及其所有子节点的层级
        function updateNodeHierarchy(nodeId) {
            const node = treeCy.$(`#${nodeId}`);
            if (node.length === 0) return;
            
            // 计算当前节点的层级
            const level = calculateNodeLevel(nodeId);
            node.data('level', level);
            
            // 更新网络图中的节点层级（如果存在）
            const networkNode = networkCy.$(`#${nodeId}`);
            if (networkNode.length > 0) {
                networkNode.data('level', level);
            }
            
            // 递归更新所有子节点的层级
            try {
                const outgoingEdges = treeCy.edges(`edge[source = "${nodeId}"][label = "PARENT_OF"]`);
                
                // 安全检查并使用合适的遍历方式
                if (outgoingEdges && typeof outgoingEdges.forEach === 'function') {
                    outgoingEdges.forEach(edge => {
                        updateNodeHierarchy(edge.data('target'));
                    });
                } else if (outgoingEdges && typeof outgoingEdges.map === 'function') {
                    // 尝试使用map方法
                    outgoingEdges.map(edge => {
                        updateNodeHierarchy(edge.data('target'));
                    });
                } else if (outgoingEdges && outgoingEdges.length > 0) {
                    // 作为最后手段，手动遍历
                    for (let i = 0; i < outgoingEdges.length; i++) {
                        updateNodeHierarchy(outgoingEdges[i].data('target'));
                    }
                }
            } catch (error) {
                console.error('更新子节点层级时出错:', error);
            }
        }
        
        // 移除父节点关系
        function removeParent(nodeId) {
            // 移除树图中的父节点关系
            treeCy.remove(`edge[target = "${nodeId}"][label = "PARENT_OF"]`);
            
            // 更新节点及其所有子节点的层级
            updateNodeHierarchy(nodeId);
            
            // 更新树图布局
            treeCy.layout().run();
            
            // 重新同步网络图
            if (networkCy.nodes().length > 0) {
                // 获取网络图中第一个节点的层级
                const currentLevel = calculateNodeLevel(networkCy.nodes().first().data('id'));
                syncNetworkWithTreeLevel(currentLevel);
            }
            
            // 从Neo4j移除父节点关系
            removeParentInNeo4j(nodeId);
        }
        
        // Add connections between nodes in network graph
        function addConnectionsToGraphs(nodeIds) {
            // Create all possible pairs
            for (let i = 0; i < nodeIds.length; i++) {
                for (let j = i + 1; j < nodeIds.length; j++) {
                    const sourceId = nodeIds[i];
                    const targetId = nodeIds[j];
                    
                    // Check if connection already exists
                    const existingEdge = networkCy.$(`edge[source = "${sourceId}"][target = "${targetId}"][label = "CONNECTED_TO"]`);
                    if (existingEdge.length === 0) {
                        // Add connection in network graph
                        networkCy.add({
                            group: 'edges',
                            data: {
                                id: `conn-${sourceId}-${targetId}`,
                                source: sourceId,
                                target: targetId,
                                label: 'CONNECTED_TO'
                            }
                        });
                    }
                }
            }
            
            // Update network layout
            networkCy.layout().run();
        }
        
        // Remove connections between nodes in network graph
        function removeConnections(nodeIds) {
            // Remove all connections between selected nodes
            for (let i = 0; i < nodeIds.length; i++) {
                for (let j = i + 1; j < nodeIds.length; j++) {
                    const sourceId = nodeIds[i];
                    const targetId = nodeIds[j];
                    
                    // Remove connection in network graph
                    networkCy.remove(`edge[source = "${sourceId}"][target = "${targetId}"][label = "CONNECTED_TO"]`);
                    networkCy.remove(`edge[source = "${targetId}"][target = "${sourceId}"][label = "CONNECTED_TO"]`);
                }
            }
            
            // Update network layout
            networkCy.layout().run();
            
            // Remove connections in Neo4j
            removeConnectionsInNeo4j(nodeIds);
        }
        
        // Add parent relationship
        async function addParent(childId, parentId) {
            // Add to graphs
            addParentToGraphs(childId, parentId);
            
            // Add to Neo4j
            await addParentInNeo4j(childId, parentId);
            
            // Update levels for all children
            const childNode = treeCy.$(`#${childId}`);
            if (childNode.length > 0) {
                const parentNode = treeCy.$(`#${parentId}`);
                if (parentNode.length > 0) {
                    const newLevel = parentNode.data('level') + 1;
                    updateNodeLevel(childId, newLevel);
                }
            }
        }
        
        // Update node level and all its children
        async function updateNodeLevel(nodeId, newLevel) {
            // Update node level in graphs
            const node = treeCy.$(`#${nodeId}`);
            if (node.length > 0) {
                node.data('level', newLevel);
                
                const networkNode = networkCy.$(`#${nodeId}`);
                if (networkNode.length > 0) {
                    networkNode.data('level', newLevel);
                }
                
                // Update in Neo4j
                await updateNodeLevelInNeo4j(nodeId, newLevel);
                
                // Update children - 使用安全的方式遍历Cytoscape集合
                const childEdges = treeCy.$(`edge[source = "${nodeId}"][label = "PARENT_OF"]`);
                try {
                    // 尝试使用不同的方法遍历Cytoscape集合
                    if (typeof childEdges.forEach === 'function') {
                        childEdges.forEach(edge => {
                            const childId = edge.data('target');
                            if (childId) {
                                updateNodeLevel(childId, newLevel + 1);
                            }
                        });
                    } else if (Array.isArray(childEdges)) {
                        // 如果是标准数组
                        for (let i = 0; i < childEdges.length; i++) {
                            const edge = childEdges[i];
                            const childId = edge.data('target');
                            if (childId) {
                                updateNodeLevel(childId, newLevel + 1);
                            }
                        }
                    } else {
                        // 尝试获取elements数组或其他常见集合形式
                        const elements = childEdges.elements ? childEdges.elements() : childEdges;
                        if (elements && typeof elements.forEach === 'function') {
                            elements.forEach(edge => {
                                const childId = edge.data('target');
                                if (childId) {
                                    updateNodeLevel(childId, newLevel + 1);
                                }
                            });
                        }
                    }
                } catch (error) {
                    console.error('遍历子节点边时出错:', error);
                }
            }
            
            // Update layouts
            treeCy.layout().run();
            networkCy.layout().run();
        }
        
        // Add connections between selected nodes
        async function addConnections(nodeIds) {
            // Add to graphs
            addConnectionsToGraphs(nodeIds);
            
            // Add to Neo4j
            await addConnectionsInNeo4j(nodeIds);
        }
        
        // Save data to Neo4j
        async function saveData() {
            try {
                // Check if connected
                if (!neo4jConfig.backendUrl) {
                    alert('请先配置并连接到Neo4j数据库');
                    return;
                }
                
                // Get all nodes and relationships from tree graph
                const nodes = treeCy.nodes().map(node => node.data());
                const parentEdges = treeCy.edges(`edge[label = "PARENT_OF"]`).map(edge => edge.data());
                
                // Get all network connections from network graph
                const networkEdges = networkCy.edges(`edge[label = "CONNECTED_TO"]`).map(edge => edge.data());
                
                // Send data to backend
                const response = await axios.post(`${neo4jConfig.backendUrl}/api/save`, {
                    nodes,
                    parentEdges,
                    networkEdges
                });
                
                if (response.data.success) {
                    alert('数据保存成功');
                } else {
                    alert('数据保存失败: ' + response.data.message);
                }
            } catch (error) {
                console.error('Error saving data:', error);
                alert('保存数据时发生错误');
            }
        }
        
        // Load data from Neo4j
        async function loadData() {
            try {
                // Check if connected
                if (!neo4jConfig.backendUrl) {
                    alert('请先配置并连接到Neo4j数据库');
                    return;
                }
                
                // Clear existing graphs
                treeCy.remove('*');
                networkCy.remove('*');
                selectedNodes = [];
                
                // Get data from backend
                const response = await axios.get(`${neo4jConfig.backendUrl}/api/load`);
                
                if (response.data.success) {
                    const { nodes, parentEdges, networkEdges } = response.data.data;
                    
                    // Add nodes to both graphs
                    nodes.forEach(node => {
                        treeCy.add({ group: 'nodes', data: node });
                        networkCy.add({ group: 'nodes', data: node });
                    });
                    
                    // Add parent edges to tree graph
                    parentEdges.forEach(edge => {
                        treeCy.add({ group: 'edges', data: edge });
                    });
                    
                    // Add network edges to network graph
                    networkEdges.forEach(edge => {
                        networkCy.add({ group: 'edges', data: edge });
                    });
                    
                    // Update layouts
                    treeCy.layout().run();
                    networkCy.layout().run();
                    
                    alert('数据加载成功');
                } else {
                    alert('数据加载失败: ' + response.data.message);
                }
            } catch (error) {
                console.error('Error loading data:', error);
                alert('加载数据时发生错误');
            }
        }
        
        // Backend API calls
        async function addNodeToNeo4j(nodeData) {
            try {
                await axios.post(`${neo4jConfig.backendUrl}/api/nodes`, nodeData);
                return true;
            } catch (error) {
                console.error('Error adding node to Neo4j:', error);
                alert('添加节点到数据库时发生错误');
                return false;
            }
        }
        
        async function updateNodeInNeo4j(nodeData) {
            try {
                await axios.put(`${neo4jConfig.backendUrl}/api/nodes/${nodeData.id}`, nodeData);
                return true;
            } catch (error) {
                console.error('Error updating node in Neo4j:', error);
                alert('更新节点到数据库时发生错误');
                return false;
            }
        }
        
        async function deleteNodesFromNeo4j(nodeIds) {
            try {
                await axios.post(`${neo4jConfig.backendUrl}/api/nodes/batch-delete`, { nodeIds });
                return true;
            } catch (error) {
                console.error('Error deleting nodes from Neo4j:', error);
                alert('从数据库删除节点时发生错误');
                return false;
            }
        }
        
        async function addParentInNeo4j(childId, parentId) {
            try {
                await axios.post(`${neo4jConfig.backendUrl}/api/tree/parent`, {
                    childId,
                    parentId
                });
                return true;
            } catch (error) {
                console.error('Error adding parent in Neo4j:', error);
                alert('添加父节点关系到数据库时发生错误');
                return false;
            }
        }
        
        async function removeParentInNeo4j(nodeId) {
            try {
                await axios.delete(`${neo4jConfig.backendUrl}/api/tree/parent/${nodeId}`);
                return true;
            } catch (error) {
                console.error('Error removing parent in Neo4j:', error);
                alert('从数据库移除父节点关系时发生错误');
                return false;
            }
        }
        
        async function updateNodeLevelInNeo4j(nodeId, level) {
            try {
                // 使用axios.put替代patch，因为patch方法可能不可用
                await axios.put(`${neo4jConfig.backendUrl}/api/nodes/${nodeId}/level`, { level });
                return true;
            } catch (error) {
                console.error('Error updating node level in Neo4j:', error);
                // 由于是模拟环境，可能不需要真正调用API
                console.log('模拟更新节点层级:', { nodeId, level });
                return true;
            }
        }
        
        async function addConnectionsInNeo4j(nodeIds) {
            try {
                await axios.post(`${neo4jConfig.backendUrl}/api/network/connect`, { nodeIds });
                return true;
            } catch (error) {
                console.error('Error adding connections in Neo4j:', error);
                alert('添加同级连接到数据库时发生错误');
                return false;
            }
        }
        
        async function removeConnectionsInNeo4j(nodeIds) {
            try {
                await axios.post(`${neo4jConfig.backendUrl}/api/network/disconnect`, { nodeIds });
                return true;
            } catch (error) {
                console.error('Error removing connections in Neo4j:', error);
                alert('从数据库移除同级连接时发生错误');
                return false;
            }
        }
        
        async function batchUpdateInNeo4j(nodeIds, key, value) {
            try {
                await axios.post(`${neo4jConfig.backendUrl}/api/nodes/batch-update`, {
                    nodeIds,
                    key,
                    value
                });
                return true;
            } catch (error) {
                console.error('Error batch updating in Neo4j:', error);
                alert('批量更新数据库时发生错误');
                return false;
            }
        }
        
        // Neo4j Connection functions
        function openNeo4jConnectionDialog() {
            const dialog = document.getElementById('neo4j-connection-dialog');
            
            // Fill form with current settings
            document.getElementById('neo4j-uri').value = neo4jConfig.uri;
            document.getElementById('neo4j-user').value = neo4jConfig.user;
            document.getElementById('neo4j-password').value = neo4jConfig.password;
            document.getElementById('neo4j-database').value = neo4jConfig.database;
            document.getElementById('backend-url').value = neo4jConfig.backendUrl;
            
            // Hide status messages
            document.getElementById('connection-status').classList.add('hidden');
            document.getElementById('connection-success').classList.add('hidden');
            document.getElementById('connection-error').classList.add('hidden');
            
            // Show dialog
            dialog.classList.remove('hidden');
        }
        
        async function testNeo4jConnection() {
            // Get form values
            const uri = document.getElementById('neo4j-uri').value;
            const user = document.getElementById('neo4j-user').value;
            const password = document.getElementById('neo4j-password').value;
            const database = document.getElementById('neo4j-database').value;
            const backendUrl = document.getElementById('backend-url').value;
            
            try {
                // Show status
                document.getElementById('connection-status').classList.remove('hidden');
                document.getElementById('connection-success').classList.add('hidden');
                document.getElementById('connection-error').classList.add('hidden');
                
                // Test backend connection
                const response = await axios.post(`${backendUrl}/api/test-connection`, {
                    uri,
                    user,
                    password,
                    database
                });
                
                if (response.data.success) {
                    // Show success
                    document.getElementById('connection-success').classList.remove('hidden');
                    document.getElementById('connection-error').classList.add('hidden');
                    return true;
                } else {
                    // Show error
                    document.getElementById('connection-error-message').textContent = response.data.message || '连接失败';
                    document.getElementById('connection-error').classList.remove('hidden');
                    document.getElementById('connection-success').classList.add('hidden');
                    return false;
                }
            } catch (error) {
                console.error('Connection test failed:', error);
                document.getElementById('connection-error-message').textContent = error.message || '连接失败，请检查网络或后端服务';
                document.getElementById('connection-error').classList.remove('hidden');
                document.getElementById('connection-success').classList.add('hidden');
                return false;
            }
        }
        
        function saveNeo4jConnectionSettings() {
            // Get form values
            const uri = document.getElementById('neo4j-uri').value;
            const user = document.getElementById('neo4j-user').value;
            const password = document.getElementById('neo4j-password').value;
            const database = document.getElementById('neo4j-database').value;
            const backendUrl = document.getElementById('backend-url').value;
            
            // Update global config
            neo4jConfig = {
                uri,
                user,
                password,
                database,
                backendUrl
            };
            
            // Save to localStorage
            localStorage.setItem('neo4j_uri', uri);
            localStorage.setItem('neo4j_user', user);
            localStorage.setItem('neo4j_password', password);
            localStorage.setItem('neo4j_database', database);
            localStorage.setItem('neo4j_backendUrl', backendUrl);
            
            // Close dialog
            document.getElementById('neo4j-connection-dialog').classList.add('hidden');
            
            // Notify user
            alert('Neo4j连接设置已保存');
        }
    </script>
</body>
</html>
