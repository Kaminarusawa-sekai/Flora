// 增强版Cytoscape.js模拟实现
window.cytoscape = function(options) {
    console.log('Cytoscape initialized with options:', options);
    
    // 存储节点和边数据
    const nodesData = [];
    const edgesData = [];
    
    // 确保window.selectedNodes存在
    if (!window.selectedNodes) {
        window.selectedNodes = [];
    }
    
    // 生成简单的DOM元素来模拟渲染
    function createDummyElements() {
        if (options.container) {
            // 清除容器内容
            options.container.innerHTML = '';
            
            // 创建一个简单的SVG容器
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '100%');
            svg.style.backgroundColor = '#f8f9fa';
            svg.style.border = '1px solid #ddd';
            
            // 添加节点的可视化表示
              nodesData.forEach((node, index) => {
                  const x = 100 + (index % 5) * 120;
                  const y = 100 + Math.floor(index / 5) * 100;
                  
                  // 创建圆形节点
                  const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                  circle.setAttribute('cx', x);
                  circle.setAttribute('cy', y);
                  circle.setAttribute('r', 30);
                  circle.setAttribute('data-id', node.id);
                  
                  // 检查节点是否被选中，使用全局window.selectedNodes
                  const isSelected = window.selectedNodes && window.selectedNodes.includes(node.id);
                  
                  // 设置节点样式
                  circle.setAttribute('fill', isSelected ? '#8B5CF6' : '#64b5f6');
                  circle.setAttribute('stroke', isSelected ? '#7C3AED' : '#1976d2');
                  circle.setAttribute('stroke-width', isSelected ? '3' : '2');
                  
                  // 添加节点文本
                  const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                  text.setAttribute('x', x);
                  text.setAttribute('y', y);
                  text.setAttribute('text-anchor', 'middle');
                  text.setAttribute('dominant-baseline', 'middle');
                  text.setAttribute('fill', '#fff');
                  text.setAttribute('font-size', '12px');
                  text.textContent = node.name || 'Node';
                  
                  // 添加点击事件以切换选中状态
                  circle.addEventListener('click', function(e) {
                      e.stopPropagation();
                      const nodeId = this.getAttribute('data-id');
                      
                      // 直接使用全局window.selectedNodes
                      const index = window.selectedNodes.indexOf(nodeId);
                      if (index > -1) {
                          // 取消选中
                          window.selectedNodes.splice(index, 1);
                      } else {
                          // 添加选中
                          window.selectedNodes.push(nodeId);
                      }
                      
                      // 重新渲染整个图以更新选中状态
                      createDummyElements();
                  });
                  
                  svg.appendChild(circle);
                  svg.appendChild(text);
              });
                
                // 添加点击SVG空白处取消所有选择
              svg.addEventListener('click', function(e) {
                  if (e.target === svg) {
                      // 清空全局selectedNodes
                      if (window.selectedNodes) {
                          window.selectedNodes.length = 0;
                      }
                      createDummyElements(); // 重新绘制以更新状态
                  }
              });
            
            // 添加边的可视化表示
            edgesData.forEach(edge => {
                const sourceNode = nodesData.find(n => n.id === edge.source);
                const targetNode = nodesData.find(n => n.id === edge.target);
                
                if (sourceNode && targetNode) {
                    const sourceIndex = nodesData.indexOf(sourceNode);
                    const targetIndex = nodesData.indexOf(targetNode);
                    
                    const sourceX = 100 + (sourceIndex % 5) * 120;
                    const sourceY = 100 + Math.floor(sourceIndex / 5) * 100;
                    const targetX = 100 + (targetIndex % 5) * 120;
                    const targetY = 100 + Math.floor(targetIndex / 5) * 100;
                    
                    // 创建线
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', sourceX);
                    line.setAttribute('y1', sourceY);
                    line.setAttribute('x2', targetX);
                    line.setAttribute('y2', targetY);
                    line.setAttribute('stroke', '#999');
                    line.setAttribute('stroke-width', '2');
                    
                    svg.appendChild(line);
                }
            });
            
            // 添加到容器
            options.container.appendChild(svg);
        }
    }
    
    // 模拟基础功能
    const cy = {
        nodes: function() {
            console.log('nodes() called');
            
            // 返回节点集合，包含filter方法
            const nodesCollection = {
                filter: function(selector) {
                    console.log('nodes().filter() called with selector:', selector);
                    
                    // 处理字符串选择器
                    const levelMatch = selector.match(/node\[data\.level\s*=\s*"(\d+)"\]/);
                    let filteredNodes = [];
                    
                    if (levelMatch) {
                        const targetLevel = parseInt(levelMatch[1]);
                        // 过滤出匹配层级的节点
                        filteredNodes = nodesData.filter(node => node.level === targetLevel);
                    } else if (selector === 'node') {
                        // 返回所有节点
                        filteredNodes = [...nodesData];
                    }
                    
                    // 返回过滤后的节点集合，包含必要方法
                    return {
                        length: filteredNodes.length,
                        first: function() {
                            if (filteredNodes.length > 0) {
                                const node = filteredNodes[0];
                                return {
                                    id: function() { return node.id; },
                                    data: function(key, value) {
                                        if (value !== undefined) {
                                            node[key] = value;
                                            return this;
                                        }
                                        return node[key] || null;
                                    }
                                };
                            }
                            return { id: function() { return null; } };
                        },
                        map: function(callback) {
                            return filteredNodes.map(node => callback({
                                id: function() { return node.id; },
                                data: function(key) {
                                    if (key === 'level') return node.level;
                                    if (key === 'name') return node.name || 'Node';
                                    if (key === 'type') return node.type || 'default';
                                    if (key === 'properties') return node.properties || {};
                                    return node[key] || null;
                                }
                            }));
                        },
                        toArray: function() {
                            return filteredNodes.map(node => ({
                                id: function() { return node.id; },
                                data: function(key) {
                                    return node[key] || null;
                                }
                            }));
                        }
                    };
                },
                toArray: function() {
                    return nodesData.map(node => ({
                        id: function() { return node.id; },
                        data: function(key) {
                            return node[key] || null;
                        }
                    }));
                }
            };
            
            return nodesCollection;
        },
        edges: function(selector) {
            console.log('edges() called with selector:', selector);
            let resultEdges = [...edgesData];
            
            // Simple filtering based on selector
            if (selector && selector.startsWith('edge')) {
                // Parse selector for source, target, and label
                let sourceId = null;
                let targetId = null;
                let label = null;
                
                const sourceMatch = selector.match(/\[source\s*=\s*"([^"]+)"\]/);
                const targetMatch = selector.match(/\[target\s*=\s*"([^"]+)"\]/);
                const labelMatch = selector.match(/\[label\s*=\s*"([^"]+)"\]/);
                
                if (sourceMatch) sourceId = sourceMatch[1];
                if (targetMatch) targetId = targetMatch[1];
                if (labelMatch) label = labelMatch[1];
                
                // Filter edges based on parsed criteria
                resultEdges = edgesData.filter(edge => {
                    if (sourceId && edge.source !== sourceId) return false;
                    if (targetId && edge.target !== targetId) return false;
                    if (label && edge.label !== label) return false;
                    return true;
                });
            }
            
            // Return edge collection with array operation support
            return {
                length: resultEdges.length,
                first: function() {
                    if (resultEdges.length > 0) {
                        const edge = resultEdges[0];
                        return {
                            id: function() { return edge.id; },
                            data: function(key, value) {
                                if (value !== undefined) {
                                    edge[key] = value;
                                    return this;
                                }
                                return edge[key] || null;
                            }
                        };
                    }
                    return { id: function() { return null; } };
                },
                map: function(callback) {
                    return resultEdges.map(edge => callback({
                        id: function() { return edge.id; },
                        data: function(key) {
                            if (key === 'source') return edge.source;
                            if (key === 'target') return edge.target;
                            if (key === 'label') return edge.label || '';
                            return edge[key] || null;
                        }
                    }));
                },
                toArray: function() {
                    return resultEdges.map(edge => ({
                        id: function() { return edge.id; },
                        data: function(key) {
                            return edge[key] || null;
                        }
                    }));
                },
                filter: function(filterFn) {
                    if (typeof filterFn === 'string') {
                        // Handle string selector
                        let filteredEdges = resultEdges;
                        
                        // Parse selector for various attributes
                        if (filterFn.includes('source')) {
                            const sourceMatch = filterFn.match(/source\s*=\s*"([^"]+)"/);
                            if (sourceMatch) {
                                filteredEdges = filteredEdges.filter(edge => edge.source === sourceMatch[1]);
                            }
                        }
                        
                        if (filterFn.includes('target')) {
                            const targetMatch = filterFn.match(/target\s*=\s*"([^"]+)"/);
                            if (targetMatch) {
                                filteredEdges = filteredEdges.filter(edge => edge.target === targetMatch[1]);
                            }
                        }
                        
                        // Return filtered collection
                        return {
                            length: filteredEdges.length,
                            first: function() {
                                if (filteredEdges.length > 0) {
                                    const edge = filteredEdges[0];
                                    return {
                                        id: function() { return edge.id; },
                                        data: function(key) { return edge[key] || null; }
                                    };
                                }
                                return { id: function() { return null; } };
                            },
                            map: function(callback) {
                                return filteredEdges.map(edge => callback({
                                    id: function() { return edge.id; },
                                    data: function(key) { return edge[key] || null; }
                                }));
                            },
                            toArray: function() {
                                return filteredEdges.map(edge => ({
                                    id: function() { return edge.id; },
                                    data: function(key) { return edge[key] || null; }
                                }));
                            }
                        };
                    }
                    return this;
                }
            };
        },
        
        // Get selected elements
        selected: function() {
            console.log('selected() called');
            // Return nodes based on window.selectedNodes
            const selectedElements = (window.selectedNodes || []).map(id => {
                const node = nodesData.find(n => n.id === id);
                if (node) {
                    return {
                        id: function() { return node.id; },
                        data: function(key) {
                            return node[key] || null;
                        },
                        style: function() { return {}; }
                    };
                }
                return null;
            }).filter(Boolean);
            
            return {
                length: selectedElements.length,
                map: function(callback) {
                    return selectedElements.map(callback);
                },
                toArray: function() {
                    return selectedElements;
                }
            };
        },
        add: function(elements) {
            console.log('add() called with elements:', elements);
            
            // 存储添加的节点和边
            if (Array.isArray(elements)) {
                elements.forEach(el => {
                    if (el.group === 'nodes' || el.data) {
                        const nodeData = el.data || el;
                        // 检查是否已存在，如果存在则更新
                        const existingIndex = nodesData.findIndex(n => n.id === nodeData.id);
                        if (existingIndex >= 0) {
                            nodesData[existingIndex] = { ...nodesData[existingIndex], ...nodeData };
                        } else {
                            nodesData.push(nodeData);
                        }
                    } else if (el.group === 'edges') {
                        const edgeData = el.data || el;
                        edgesData.push(edgeData);
                    }
                });
            } else if (elements) {
                // 单个元素
                if (elements.group === 'nodes' || elements.data) {
                    const nodeData = elements.data || elements;
                    const existingIndex = nodesData.findIndex(n => n.id === nodeData.id);
                    if (existingIndex >= 0) {
                        nodesData[existingIndex] = { ...nodesData[existingIndex], ...nodeData };
                    } else {
                        nodesData.push(nodeData);
                    }
                } else if (elements.group === 'edges') {
                    edgesData.push(elements.data || elements);
                }
            }
            
            // 更新视图
            createDummyElements();
            
            return cy;
        },
        remove: function(selector) {
            console.log('remove() called with selector:', selector);
            
            // 移除匹配的元素
            if (selector && selector.charAt(0) === '#') {
                const idToRemove = selector.substring(1);
                const nodeIndex = nodesData.findIndex(n => n.id === idToRemove);
                if (nodeIndex >= 0) {
                    nodesData.splice(nodeIndex, 1);
                }
            }
            
            // 更新视图
            createDummyElements();
            
            return cy;
        },
        on: function(event, callback) {
            console.log('on() called for event:', event);
            return cy;
        },
        $: function(selector) {
            console.log('$() called with selector:', selector);
            
            // 处理ID选择器
            if (selector && selector.charAt(0) === '#') {
                const id = selector.substring(1);
                const node = nodesData.find(n => n.id === id);
                
                if (node) {
                    return {
                        length: 1,
                        data: function(key, value) {
                            console.log('node.data() called with key:', key, 'value:', value);
                            if (value !== undefined) {
                                node[key] = value;
                                return this;
                            }
                            if (key === 'name') return node.name || 'New Node';
                            if (key === 'type') return node.type || 'default';
                            if (key === 'level') return node.level || 0;
                            if (key === 'properties') return node.properties || {};
                            return node[key] || null;
                        }
                    };
                }
            }
            
            // 返回空结果
            return {
                length: 0,
                data: function(key, value) {
                    console.log('node.data() called with key:', key, 'value:', value);
                    if (key === 'name') return 'New Node';
                    if (key === 'type') return 'default';
                    if (key === 'level') return 0;
                    if (key === 'properties') return {};
                    return null;
                }
            };
        },
        style: function(style) {
            console.log('style() called with style:', style);
            return cy;
        },
        resize: function() {
            console.log('resize() called');
            // 更新视图
            createDummyElements();
            return cy;
        },
        fit: function() {
            console.log('fit() called');
            return cy;
        },
        layout: function(options) {
            console.log('layout() called with options:', options);
            return {
                run: function() {
                    console.log('layout().run() called');
                    // 重新布局后更新视图
                    createDummyElements();
                    return this;
                }
            };
        },
        // 添加data方法以支持数据访问
        data: function(key, value) {
            if (value !== undefined) {
                return this;
            }
            return null;
        }
    };
    
    // 确保使用与index.html中相同的selectedNodes变量
     // 不在这里初始化，由index.html初始化并维护
    
    // 初始创建空视图
    createDummyElements();
    
    // 触发ready事件
    setTimeout(() => {
        if (options.ready) {
            options.ready(cy);
        }
    }, 0);
    
    return cy;
};

// 触发Cytoscape ready事件
setTimeout(() => {
    if (window.addEventListener) {
        window.dispatchEvent(new Event('cytoscape.ready'));
    }
}, 100);
// 简单模拟Cytoscape的ready事件
setTimeout(() => {
    if (window.onCytoscapeReady) {
        window.onCytoscapeReady();
    }
}, 100);