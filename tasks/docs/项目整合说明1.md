# Flora Agent 系统架构说明

## 项目概述

Flora Agent 是一个基于 Thespian Actor 模型的智能体系统，支持任务管理、循环任务调度、插件化能力扩展等功能。

---

# 最新架构更新 - 前后台分离重构 (2025)

## 重构概述

本次重构实现了**前台（对话处理）-后台（任务执行）**完全分离的架构，形成了清晰的职责划分和消息流转机制。

## 新架构核心组件

### 1. RouterActor（路由层）
- **职责**：全局唯一路由，管理AgentActor实例的唯一性
- **位置**：`agents/router_actor.py`
- **功能**：
  - 确保同一租户和节点下只有一个AgentActor实例
  - 维护Actor引用的注册和注销
  - 提供心跳机制确保系统健壮性

### 2. InteractionActor（前台层）
- **职责**：前台对话处理，系统唯一的用户交互入口
- **位置**：`agents/interaction_actor.py`
- **功能**：
  - 接收用户输入
  - 使用ConversationManager处理对话逻辑
  - 判断用户意图和状态
  - 处理参数补充场景
  - 转发任务给后台AgentActor
  - 返回执行结果给用户

**关键消息类型**：
- `user_input`: 接收用户输入
- `task_paused`: 处理后台返回的任务暂停通知
- `task_completed`: 处理任务完成通知
- `task_error`: 处理任务错误

### 3. ConversationManager（对话管理）
- **职责**：管理对话状态、草稿和参数补充
- **位置**：`capabilities/context/conversation_manager.py`
- **功能**：
  - **前台核心能力**：`handle_user_input()` - 统一的用户输入处理入口
  - **参数识别**：判断用户是否在补充参数
  - **任务暂停**：`pause_task_for_parameters()` - 暂停任务等待参数
  - **参数补充**：`complete_task_parameters()` - 完成参数补充
  - **任务恢复**：通知后台继续执行

**核心方法**：
```python
def handle_user_input(user_input: str, user_id: str) -> Dict[str, Any]:
    """
    Returns:
        - action: "new_task" | "parameter_completion" | "chat" | "clarification"
        - task_id: 任务ID（如果适用）
        - parameters: 补充的参数
        - message: 返回给用户的消息
        - needs_backend: 是否需要后台处理
    """
```

### 4. AgentActor（后台层）
- **职责**：后台任务执行，专注于任务规划和调度
- **位置**：`agents/agent_actor.py`
- **功能**：
  - 接收来自前台的任务请求
  - 任务意图判断
  - 任务规划和分解
  - 调度ExecutionActor执行具体任务
  - 聚合子任务结果
  - 将结果返回给前台

**关键消息类型**：
- `agent_task`: 接收新任务
- `resume_task`: 恢复暂停的任务
- `task_paused`: 转发ExecutionActor的暂停通知
- `subtask_result`: 接收子任务结果

### 5. ExecutionActor（执行层）
- **职责**：具体任务执行，连接外部系统
- **位置**：`capability_actors/execution_actor.py`
- **功能**：
  - 执行Dify工作流
  - 执行HTTP请求
  - 执行数据查询
  - 执行通用能力函数
  - **参数检查**：发现缺失参数时暂停任务
  - **任务恢复**：接收补充参数后继续执行

**参数补充机制**：
```python
def _request_missing_parameters(task_id, missing_params, parameters, reply_to):
    """
    1. 调用ConversationManager.pause_task_for_parameters()
    2. 发送task_paused消息给AgentActor
    3. AgentActor转发给InteractionActor
    4. InteractionActor通知用户补充参数
    """
```

## 新消息流程

### 完整的任务执行流程

```
1. 用户输入
   ↓
2. InteractionActor.receiveMessage("user_input")
   ↓
3. ConversationManager.handle_user_input()
   ├─ 检查是否在补充参数
   ├─ 判断意图
   └─ 返回 action 和 needs_backend
   ↓
4. 如果 needs_backend = true
   ↓
5. InteractionActor → AgentActor ("agent_task")
   ↓
6. AgentActor 任务规划
   ↓
7. AgentActor → ExecutionActor ("execute")
   ↓
8. ExecutionActor 执行任务
   ├─ 如果缺少参数
   │   ↓
   │   8a. ExecutionActor → ConversationManager.pause_task_for_parameters()
   │   ↓
   │   8b. ExecutionActor → AgentActor ("task_paused")
   │   ↓
   │   8c. AgentActor → InteractionActor ("task_paused")
   │   ↓
   │   8d. InteractionActor → User (询问参数)
   │   ↓
   │   8e. User 输入参数
   │   ↓
   │   8f. InteractionActor → ConversationManager.handle_user_input()
   │   ↓
   │   8g. ConversationManager.complete_task_parameters()
   │   ↓
   │   8h. InteractionActor → AgentActor ("resume_task")
   │   ↓
   │   8i. AgentActor → ExecutionActor ("resume_execution")
   │   ↓
   │   返回步骤8继续执行
   │
   └─ 如果参数完整，直接执行
       ↓
9. ExecutionActor → AgentActor ("subtask_result")
   ↓
10. AgentActor → InteractionActor ("task_completed")
    ↓
11. InteractionActor → User (返回结果)
```

## 关键设计模式

### 1. 前后台分离模式
- **前台**（InteractionActor + ConversationManager）：负责所有对话逻辑
- **后台**（AgentActor + ExecutionActor）：负责任务执行
- **优点**：职责清晰，易于扩展和维护

### 2. 参数动态补充模式
- 任务链可以在执行过程中暂停
- 前台接管参数补充流程
- 参数补充完成后自动恢复任务链
- **优点**：支持复杂的参数收集场景

### 3. 消息转发模式
- ExecutionActor → AgentActor → InteractionActor
- 保持ExecutionActor无状态，不直接与前台通信
- **优点**：解耦执行层和交互层

### 4. 唯一路由模式
- RouterActor确保同一租户/节点只有一个AgentActor实例
- 使用Redis或内存字典管理Actor引用
- **优点**：防止资源浪费和状态冲突

---

# 原有架构说明

## 1. 消息处理流程（AgentActor）

当 `AgentActor` 收到任务消息后，按以下步骤处理：

```
用户输入
  ↓
① 草稿判断（TaskDraft）
  ├─ 检查是否为"继续"请求
  ├─ 恢复未完成的草稿
  └─ 或创建新草稿
  ↓
② 意图判断（IntentRouter）
  ├─ 使用 Qwen LLM 分类意图
  ├─ 判断：task / query / chat / system
  └─ 需要澄清时返回澄清选项
  ↓
③ 任务操作判断（TaskPlanner）
  ├─ new_task: 创建新任务
  ├─ comment_on_task: 追加评论
  ├─ revise_result: 修改结果
  ├─ re_run_task: 重新执行
  ├─ cancel_task: 取消任务
  └─ 循环任务操作: trigger/modify/pause/resume
  ↓
④ 循环任务检测
  ├─ 使用 LLM 判断是否为循环任务
  ├─ 是 → 注册到 LoopSchedulerActor
  │     ├─ 发送到 RabbitMQ
  │     ├─ RabbitBridge 桥接到 Thespian
  │     └─ 定时触发执行
  └─ 否 → 继续普通任务流程
  ↓
⑤ 能力路由（TaskRouter）
  ├─ 根据任务描述选择最佳能力节点
  └─ 未找到 → 使用 MCP Fallback
  ↓
⑥ 任务规划（TaskPlanner）
  ├─ 生成子任务执行计划
  └─ 支持 SCC 强耦合任务协同规划
  ↓
⑦ 任务分发（ExecutionActor）
  ├─ 创建子任务
  ├─ 分配到执行器
  └─ 跟踪执行状态
  ↓
⑧ 组任务管理（TaskGroupAggregatorActor）
  ├─ 批量分发子任务
  ├─ 支持任务重试
  └─ 聚合执行结果
  ↓
⑨ 并行执行判断（parallel_task_aggregator_actor.py）
  ├─ 判断是否需要并行执行
  ├─ 使用 Optuna 进行参数优化
  └─ 并发执行多个任务
  ↓
⑩ 单任务执行（ResultAggregatorActor）
  ├─ leaf_task: 叶子节点任务
  ├─ intermediate_task: 中间任务
  └─ workflow_task: 工作流任务（Dify）
  ↓
⑪ 结果聚合（ResultAggregator）
  ├─ 收集所有子任务结果
  ├─ 按策略聚合（map_reduce / voting / weighted）
  └─ 返回最终结果
  ↓
⑫ 事件通知（EventBus）
  ├─ 发布任务状态变更事件
  ├─ 通知订阅者
  └─ 记录任务历史
```

## 2. 核心组件

#### 2.1 AgentActor (agents/agent_actor.py)
- 核心消息处理器
- 协调所有能力模块
- 管理任务生命周期

#### 2.2 LoopSchedulerActor (capability_actors/loop_scheduler_actor.py)
- 循环任务调度
- RabbitMQ 集成
- 任务触发管理

#### 2.3 TaskCoordinator (agents/coordination/task_coordinator.py)
- 任务协调
- 子任务生成
- 状态跟踪

#### 2.4 TaskExecutionService (capability_actors/task_execution_service.py)
- 任务执行引擎
- 支持多种任务类型
- 资源管理

#### 2.5 EventBus (events/event_bus.py)
- 事件发布/订阅
- 解耦组件通信
- 事件历史记录

## 3. 插件系统

所有能力组件都通过 `CapabilityRegistry` 插件式注册：

```python
from capabilities.registry import capability_registry
from init_plugins import init_plugins

# 初始化所有插件
init_plugins()

# 获取能力
router = capability_registry.get_capability("routing")
planner = capability_registry.get_capability("planning")
```

已注册的能力：
- `routing`: TaskRouter - 任务路由
- `planning`: TaskPlanner - 任务规划
- `context_resolver`: ContextResolver - 上下文解析
- `result_aggregation`: ResultAggregator - 结果聚合
- `parallel_optimization`: OptunaOptimizer - 并行优化
- `optimization`: MultiFeatureOptimizer - 循环优化
- `memory`: MemoryCapability - 记忆能力
- `decision_engine`: DecisionEngine - 决策引擎
- `data_access`: DataAccessor - 数据访问
- `loop_queue`: QueueFactory - 循环队列
- `llm`: QwenAdapter - LLM 能力
- `conversation_manager`: ConversationManagerCapability - 对话管理 (新增)
- `intent_router`: IntentRouterCapability - 意图路由 (新增)

## 4. 系统启动

### 启动命令

```bash
# 标准启动
python main.py

# 启动并发送测试消息
python main.py --test

# 调试模式
python main.py --debug
```

### 系统初始化顺序

1. 初始化能力模块（`init_capabilities()`）
2. 创建Actor系统
3. 启动RouterActor（全局唯一路由）
4. 启动AgentActor（后台）
5. 启动InteractionActor（前台）
6. 配置前后台连接
7. 启动LoopSchedulerActor（循环任务）
8. (可选) 启动API服务器

## 5. 事件系统

系统在关键节点发布事件：

```python
from events.event_bus import event_bus
from events.event_types import EventType

# 发布任务事件
event_bus.publish_task_event(
    task_id=task_id,
    event_type=EventType.TASK_STARTED.value,
    source="AgentActor",
    agent_id=self.agent_id,
    data={"description": task_description}
)
```

支持的事件类型：
- TASK_CREATED: 任务创建
- TASK_STARTED: 任务开始
- TASK_COMPLETED: 任务完成
- TASK_FAILED: 任务失败
- TASK_CANCELLED: 任务取消
- TASK_PAUSED: 任务暂停 (新增)
- TASK_RESUMED: 任务恢复 (新增)
- LOOP_TASK_REGISTERED: 循环任务注册
- TASK_TRIGGERED: 任务触发

## 6. 循环任务管理

### 6.1 RabbitMQ 桥接
```
RabbitMQ Queue (loop.trigger.queue)
    ↓
RabbitBridge (rabbit_bridge.py)
    ↓
LoopSchedulerActor (Thespian)
    ↓
AgentActor (执行任务)
```

### 6.2 循环任务注册流程
1. AgentActor 检测到循环任务
2. 向 LoopSchedulerActor 注册任务
3. LoopSchedulerActor 保存到 TaskRegistry
4. 定时触发或通过 RabbitMQ 触发
5. 执行任务并更新状态

## 7. 依赖关系

```
agents/
  ├── router_actor.py (新增 - Actor唯一性路由)
  ├── interaction_actor.py (新增 - 前台对话处理)
  ├── agent_actor.py (重构 - 专注任务执行)
  └── coordination/
      └── task_coordinator.py

capabilities/
  ├── registry.py (中心注册表)
  ├── context/
  │   └── conversation_manager.py (新增 - 对话管理)
  ├── cognition/
  │   └── intent_router.py (意图路由)
  ├── routing/
  │   ├── task_router.py
  │   ├── task_planner.py
  │   └── context_resolver.py
  ├── llm/
  │   └── qwen_adapter.py
  └── llm_memory/
      └── memory_capability.py

capability_actors/
  ├── execution_actor.py (增强 - 参数暂停/恢复)
  ├── loop_scheduler_actor.py
  ├── task_execution_service.py
  └── task_group_aggregator_actor.py

events/
  ├── event_bus.py
  └── event_types.py

common/
  ├── draft/
  ├── intent/
  └── tasks/
```

## 使用示例

### 创建简单任务

```python
from thespian.actors import ActorSystem
from agents.interaction_actor import InteractionActor

# 创建 Actor System
system = ActorSystem("simpleSystemBase")

# 创建 InteractionActor (前台入口)
interaction = system.createActor(InteractionActor)

# 配置后台 (在实际系统中由 main.py 完成)
# system.tell(interaction, {"message_type": "configure", "backend_addr": agent_addr})

# 发送用户输入
user_msg = {
    "message_type": "user_input",
    "user_id": "user_001",
    "content": "帮我查询一下上个月的销售数据",
    "msg_id": "msg_001"
}
result = system.ask(interaction, user_msg, timeout=60)
print(result)
```

### 参数补充场景

```python
# 1. 发送需要参数的任务
task_msg = {
    "message_type": "user_input",
    "user_id": "user_001",
    "content": "执行Dify工作流"  # 缺少api_key等参数
}
response = system.ask(interaction, task_msg, timeout=60)
# 系统会返回询问参数的消息

# 2. 补充参数
param_msg = {
    "message_type": "user_input",
    "user_id": "user_001",
    "content": "sk-xxxxx"  # 提供api_key
}
final_result = system.ask(interaction, param_msg, timeout=120)
# 系统自动恢复任务执行并返回结果
```

## 注意事项

1. **消息格式**: 所有消息必须包含 `message_type` 字段
2. **reply_to**: 任务消息必须携带 `reply_to` 地址，用于返回结果
3. **task_id**: 任务必须有唯一的 `task_id`，用于跟踪和恢复
4. **user_id**: 用户消息应包含 `user_id`，用于区分不同用户的待处理任务
5. **状态管理**: ConversationManager管理所有用户的待处理任务状态
6. **插件注册**: 所有能力必须在 `init_capabilities()` 中注册
7. **事件发布**: 在关键状态变更时发布事件
8. **Actor 生命周期**: 避免阻塞操作，使用消息传递
9. **错误处理**: 使用 try-except 包裹外部调用
10. **配置管理**: 通过 `config.py` 管理全局配置

## 重构完成事项

- [x] 增强ConversationManager，完善参数识别和任务暂停恢复机制
- [x] 重构InteractionActor，作为前台唯一入口
- [x] 精简AgentActor，移除对话处理逻辑，专注于任务执行
- [x] 增强ExecutionActor，支持参数缺失时暂停任务链
- [x] 集成RouterActor到main.py，确保Actor唯一路由
- [x] 创建前后台分离架构文档

## 待完善项

- [ ] 持久化待处理任务到数据库
- [ ] 支持分布式部署（使用 multiprocTCPBase）
- [ ] 添加性能监控和详细日志
- [ ] 增强任务失败后的自动恢复机制
- [ ] 添加任务并发数限制和队列管理
- [ ] 添加更多事件发布点
- [ ] 编写完整的集成测试
- [ ] 添加 API 文档
