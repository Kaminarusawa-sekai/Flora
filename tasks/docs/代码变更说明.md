根据你提供的 Server 端代码（基于 FastAPI 和 Pydantic），我们需要重构 Client 端代码以完全匹配后端的 API 契约。

**主要修改点：**

1. **API 模型对齐**：Client 构造的 payload 必须严格符合 Server 的 `AdHocTaskRequest` 模型（包括 `schedule_type`, `schedule_config` 等字段）。
2. **Request ID 支持**：
   - `submit_task` 现在允许传入 `request_id`。
   - **自动转换机制**：为了满足你提到的“如果输入是 request_id 要自动转换”，我在 Client 内部增加了一个简单的**内存映射缓存 (`_request_trace_map`)**。当你通过 Client 提交任务时，它会自动记录 `request_id -> trace_id` 的关系。后续调用 `cancel_task` 等方法时，如果你只传了 `request_id`，Client 会自动尝试查找对应的 `trace_id`。

以下是适配后的代码：

Python

```
from typing import Dict, Any, Optional, Union
import requests
import uuid
import logging

# 配置简单的日志
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class TaskClient:
    """
    任务执行客户端 (适配 Server 的 AdHocTaskRequest 模型)
    """
    
    def __init__(self, base_url: str = "http://external-task-system/api/v1"):
        self.base_url = base_url.rstrip('/')
        # 用于本地缓存 request_id -> trace_id 的映射，实现自动转换
        # 注意：如果是多进程/分布式Client，这个映射需要存放在Redis等外部存储中
        self._request_trace_map: Dict[str, str] = {}

    def _call_api(self, method: str, endpoint: str, json: Optional[Dict] = None, params: Optional[Dict] = None) -> Dict[str, Any]:
        """统一的内部调用方法，处理异常和响应状态"""
        url = f"{self.base_url}{endpoint}"
        try:
            response = requests.request(method, url, json=json, params=params)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            logger.error(f"API Call Failed: {method} {url} | Error: {str(e)}")
            # 尝试读取后端返回的详细错误信息
            error_detail = "Unknown error"
            if e.response is not None:
                try:
                    error_detail = e.response.json().get('detail', e.response.text)
                except ValueError:
                    error_detail = e.response.text
            raise Exception(f"Task System Error: {error_detail}")

    def _resolve_trace_id(self, trace_id: Optional[str], request_id: Optional[str]) -> str:
        """
        核心逻辑：ID 自动转换
        如果传入了 trace_id，直接使用。
        如果只传入 request_id，则从本地映射中查找对应的 trace_id。
        """
        if trace_id:
            return trace_id
        
        if request_id:
            found_trace_id = self._request_trace_map.get(request_id)
            if found_trace_id:
                logger.info(f"Auto-resolved request_id [{request_id}] to trace_id [{found_trace_id}]")
                return found_trace_id
            else:
                raise ValueError(f"无法找到 request_id [{request_id}] 对应的 trace_id，请确保任务是经由本客户端实例提交，或直接提供 trace_id。")
        
        raise ValueError("必须提供 trace_id 或 request_id 其中之一")

    def submit_task(
        self,
        task_name: str,
        task_content: Dict[str, Any],
        parameters: Dict[str, Any],
        user_id: str,
        request_id: Optional[str] = None
    ) -> str:
        """
        提交即席任务 (Immediate / Once)
        
        Args:
            request_id: 可选。如果不传，Client 会自动生成一个 UUID。
        
        Returns:
            trace_id: 后端生成的追踪ID
        """
        # 1. 准备 Request ID
        req_id = request_id or str(uuid.uuid4())
        
        # 2. 注入 User ID
        parameters["_user_id"] = user_id

        # 3. 构造符合 Server AdHocTaskRequest 的 Payload
        payload = {
            "task_name": task_name,
            "task_content": task_content,
            "input_params": parameters,
            "is_temporary": True,
            "schedule_type": "IMMEDIATE", # 显式指定
            "schedule_config": None,
            "loop_config": None,
            "request_id": req_id  # 传递给后端
        }

        # 4. 调用接口
        resp_data = self._call_api("POST", "/ad-hoc-tasks", json=payload)
        
        trace_id = resp_data["trace_id"]
        
        # 5. [关键] 记录映射关系，以便后续通过 request_id 操作
        self._request_trace_map[req_id] = trace_id
        
        return trace_id

    def submit_cron_task(
        self,
        task_name: str,
        task_content: Dict[str, Any],
        parameters: Dict[str, Any],
        user_id: str,
        cron_expression: str,
        request_id: Optional[str] = None
    ) -> str:
        """
        提交 Crontab 定时任务
        对应 Server schedule_type="CRON"
        """
        req_id = request_id or str(uuid.uuid4())
        parameters["_user_id"] = user_id

        payload = {
            "task_name": task_name,
            "task_content": task_content,
            "input_params": parameters,
            "is_temporary": True,
            "schedule_type": "CRON",
            "schedule_config": {
                "cron_expression": cron_expression
            },
            "request_id": req_id
        }

        resp_data = self._call_api("POST", "/ad-hoc-tasks", json=payload)
        trace_id = resp_data["trace_id"]
        self._request_trace_map[req_id] = trace_id
        return trace_id

    def submit_loop_task(
        self,
        task_name: str,
        task_content: Dict[str, Any],
        parameters: Dict[str, Any],
        user_id: str,
        interval_seconds: int,
        max_runs: Optional[int] = None,
        request_id: Optional[str] = None
    ) -> str:
        """
        提交循环任务 (Loop)
        对应 Server schedule_type="LOOP" 和 loop_config
        """
        req_id = request_id or str(uuid.uuid4())
        parameters["_user_id"] = user_id

        payload = {
            "task_name": task_name,
            "task_content": task_content,
            "input_params": parameters,
            "is_temporary": True,
            "schedule_type": "LOOP",
            # 根据Server注释：LOOP模式下配置放 loop_config，schedule_config可不传
            "loop_config": {
                "interval_sec": interval_seconds,
                "max_rounds": max_runs if max_runs else 0
            },
            "request_id": req_id
        }

        resp_data = self._call_api("POST", "/ad-hoc-tasks", json=payload)
        trace_id = resp_data["trace_id"]
        self._request_trace_map[req_id] = trace_id
        return trace_id

    # -------------------------------------------------------------------
    # 控制类方法：支持 trace_id 或 request_id
    # -------------------------------------------------------------------

    def cancel_task(self, trace_id: Optional[str] = None, request_id: Optional[str] = None) -> Dict[str, Any]:
        """
        取消任务 (Trace级别)
        允许传入 trace_id 或 request_id (自动转换)
        """
        # 自动转换 ID
        target_trace_id = self._resolve_trace_id(trace_id, request_id)
        
        # 调用 Server 的 trace cancel 接口
        endpoint = f"/traces/{target_trace_id}/cancel"
        return self._call_api("POST", endpoint)

    def stop_task(self, trace_id: Optional[str] = None, request_id: Optional[str] = None) -> Dict[str, Any]:
        """
        停止任务（当前映射到 Cancel，因为 Server 只提供了 Cancel）
        """
        return self.cancel_task(trace_id, request_id)

    # -------------------------------------------------------------------
    # 实例(Instance)级别控制
    # 如果你知道具体的 instance_id，可以直接调用；
    # 但通常即席任务只关心 trace_id。
    # -------------------------------------------------------------------
    
    def pause_instance(self, instance_id: str) -> Dict[str, Any]:
        """暂停特定实例"""
        return self._call_api("POST", f"/instances/{instance_id}/pause")

    def resume_instance(self, instance_id: str) -> Dict[str, Any]:
        """恢复特定实例"""
        return self._call_api("POST", f"/instances/{instance_id}/resume")

    # -------------------------------------------------------------------
    # 查询状态
    # 注意：Server 代码中没有显式的 GET /traces/{id} 接口，
    # 但通常这是一个标准需求。这里假设 Server 补全了该查询接口，
    # 或者你需要使用 list 接口过滤。
    # -------------------------------------------------------------------
    
    def get_task_status(self, trace_id: Optional[str] = None, request_id: Optional[str] = None) -> Dict[str, Any]:
        """
        查询任务状态
        """
        target_trace_id = self._resolve_trace_id(trace_id, request_id)
        
        # 假设 Server 有个 GET /traces/{trace_id} 或者是 list 过滤
        # 由于 Server 代码仅展示了 Definition list，这里作为示例：
        # 实际可能需要调用 DB 或 Redis 直接查，或者让 Server 增加此接口。
        # 此处代码仅为逻辑占位，需确认 Server 路由。
        try:
             # 假设存在这个接口
            return self._call_api("GET", f"/traces/{target_trace_id}")
        except Exception:
            # 如果 Server 没这个接口，返回本地已知信息
            return {
                "trace_id": target_trace_id,
                "request_id": request_id,
                "status": "UNKNOWN (Server missing status endpoint)"
            }
```

### 代码变更说明

1. **`_resolve_trace_id` 方法**：
   - 这是实现你要求的“输入 request_id 自动转换”的核心。
   - 它优先使用 `trace_id`。
   - 如果没有 `trace_id` 但有 `request_id`，它会去 `self._request_trace_map` 字典里查。
2. **`submit_task` (以及新的 `submit_cron_task`, `submit_loop_task`)**：
   - **Payload 结构**：完全按照 `AdHocTaskRequest` Pydantic 模型重写，包含 `schedule_type`, `is_temporary` 等字段。
   - **Loop 配置**：根据 Server 的注释，LOOP 模式使用 `loop_config` 字段，而不是 `schedule_config`，我在 `submit_loop_task` 中做了特殊处理。
   - **Request ID**：即使你不传，Client 也会生成一个 UUID 传给 Server，这样保证了全链路都有 ID 可查。
3. **控制接口 (`cancel_task`)**：
   - Server 的路由是 `@router.post("/traces/{trace_id}/cancel")`。
   - Client 现在会动态拼接这个 URL。

### 如何使用 (示例)

Python

```
client = TaskClient(base_url="http://localhost:8000")

# 1. 使用自定义 request_id 提交任务
my_req_id = "req_2023_001"
trace_id = client.submit_task(
    task_name="data_process",
    task_content={"script": "run.py"},
    parameters={"data": "raw"},
    user_id="user_1",
    request_id=my_req_id  # <--- 传入 request_id
)

print(f"Trace ID: {trace_id}")

# 2. 稍后，你可以直接用 request_id 来取消任务
# Client 会自动在内部查找 my_req_id 对应的 trace_id 并发送给 Server
client.cancel_task(request_id=my_req_id) 

# 或者传统的用法
client.cancel_task(trace_id=trace_id)
```

